{% extends 'api/base.html' %}
{% load static %}

{% block title %}Carousel Editor - Customize Your Slides{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/editor.css' %}">
<style>
    /* Additional styles for image handling */
    .slide-item-preview-img {
        width: 100%;
        height: 60px;
        background-size: cover;
        background-position: center;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 0.75rem;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    .image-preview {
        width: 100%;
        height: 120px;
        background: var(--light);
        border-radius: 8px;
        overflow: hidden;
        margin-top: 0.5rem;
        border: 2px solid var(--light-gray);
    }

    .image-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .saystorys-container {
        position: relative;
        background: #f5f5f5;
        border-radius: var(--border-radius);
        overflow: hidden;
        box-shadow: var(--shadow);
        min-height: 500px;
    }

    #konvaContainer {
        width: 100%;
        height: 100%;
        background: white;
    }

    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.85);
        backdrop-filter: blur(20px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    }

    .loading-content {
        text-align: center;
        max-width: 400px;
        padding: 2.5rem;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: var(--border-radius-lg);
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
    }

    .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid var(--light-gray);
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 2rem;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    /* ========== EDITOR LAYOUT ========== */
    .editor-container {
        display: grid;
        grid-template-columns: 320px 1fr 360px;
        min-height: calc(100vh - 80px);
        background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        font-family: var(--font-family-primary);
        gap: var(--spacing-lg);
        padding: var(--spacing-lg);
    }

    /* ========== LEFT SIDEBAR ========== */
    .editor-sidebar {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: var(--border-radius-lg);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: var(--spacing-xl);
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        transition: all var(--transition-normal);
    }

    .editor-sidebar:hover {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    }

    .editor-sidebar::-webkit-scrollbar {
        width: 8px;
    }

    .editor-sidebar::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.05);
        border-radius: 4px;
    }

    .editor-sidebar::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        transition: background var(--transition-fast);
    }

    .editor-sidebar::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.3);
    }

    .sidebar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--spacing-xl);
        padding-bottom: var(--spacing-lg);
        border-bottom: 2px solid rgba(99, 102, 241, 0.1);
    }

    .sidebar-header h3 {
        font-size: 1.2rem;
        font-weight: 700;
        color: var(--dark);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .sidebar-header h3 i {
        color: var(--primary);
    }

    .slides-list {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-xl);
        flex: 1;
        max-height: 750px;
        overflow-y: auto;
        padding-right: 5px;
    }

    .slides-list::-webkit-scrollbar {
        width: 6px;
    }

    .slides-list::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.05);
        border-radius: 4px;
    }

    .slides-list::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        transition: background var(--transition-fast);
    }

    .slides-list::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.3);
    }

    .slide-item {
        padding: var(--spacing-lg);
        background: var(--light);
        border-radius: var(--border-radius-lg);
        border: 2px solid transparent;
        cursor: pointer;
        transition: all var(--transition-normal);
        position: relative;
        overflow: hidden;
        flex-shrink: 0;
        /* Prevent shrinking when list scrollbar activates */
    }

    .slide-item::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.05) 0%, rgba(139, 92, 246, 0.05) 100%);
        opacity: 0;
        transition: opacity var(--transition-normal);
    }

    .slide-item:hover::before {
        opacity: 1;
    }

    .slide-item:hover {
        border-color: var(--primary);
        background: var(--primary-light);
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
    }

    .slide-item.active {
        border-color: var(--primary);
        background: var(--primary-light);
        box-shadow: var(--shadow-glow);
    }

    .slide-item.active::before {
        opacity: 1;
    }

    .slide-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--spacing-sm);
    }

    .slide-item-actions {
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
    }

    .delete-slide-btn {
        background: none;
        border: none;
        color: var(--gray-400);
        cursor: pointer;
        padding: var(--spacing-xs);
        border-radius: var(--border-radius-sm);
        transition: all var(--transition-fast);
        font-size: 0.75rem;
        opacity: 0.7;
    }

    .delete-slide-btn:hover {
        background: rgba(239, 68, 68, 0.1);
        color: var(--error);
        opacity: 1;
        transform: scale(1.1);
    }

    .slide-item-title {
        font-weight: 600;
        font-size: 0.9rem;
        color: var(--dark);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
    }

    .slide-item-preview {
        width: 100%;
        height: 80px;
        background: var(--gray-100);
        border-radius: var(--border-radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--gray-400);
        font-size: 0.75rem;
        text-align: center;
        overflow: hidden;
        position: relative;
    }

    .slide-item-preview-img {
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        border-radius: var(--border-radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 0.75rem;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        position: relative;
    }

    .slide-item-preview-img::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.1) 0%, rgba(0, 0, 0, 0.3) 100%);
        border-radius: var(--border-radius-md);
    }

    /* ========== DESIGN TOOLS ========== */
    .sidebar-section {
        margin-bottom: var(--spacing-xl);
        padding: var(--spacing-lg);
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(5px);
        border-radius: var(--border-radius-lg);
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        transition: all var(--transition-normal);
    }

    .sidebar-section:hover {
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        transform: translateY(-1px);
    }

    .sidebar-section h4 {
        font-size: 1.1rem;
        font-weight: 700;
        color: var(--dark);
        margin-bottom: var(--spacing-lg);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .sidebar-section h4 i {
        color: var(--primary);
        opacity: 0.8;
    }

    .design-tools {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
    }

    .tool-group {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
    }

    .tool-group label {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--gray-700);
    }

    .tool-group input[type="color"] {
        width: 60px;
        height: 40px;
        border: 2px solid var(--gray-300);
        border-radius: var(--border-radius-md);
        cursor: pointer;
        transition: all var(--transition-normal);
    }

    .tool-group input[type="color"]:hover {
        border-color: var(--primary);
        transform: scale(1.05);
    }

    .tool-group select {
        padding: var(--spacing-sm) var(--spacing-md);
        border: 2px solid var(--gray-300);
        border-radius: var(--border-radius-md);
        font-size: 0.875rem;
        background: var(--light);
        color: var(--dark);
        cursor: pointer;
        transition: all var(--transition-normal);
        font-family: var(--font-family-primary);
    }

    .tool-group select:hover {
        border-color: var(--primary);
    }

    .tool-group select:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px var(--primary-light);
    }

    /* ========== IMAGE GENERATOR ========== */
    .image-generator {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
    }

    .image-generator textarea {
        padding: var(--spacing-md);
        border: 2px solid var(--gray-300);
        border-radius: var(--border-radius-md);
        font-family: var(--font-family-primary);
        font-size: 0.875rem;
        color: var(--dark);
        resize: vertical;
        min-height: 80px;
        transition: all var(--transition-normal);
        background: var(--light);
        line-height: 1.5;
    }

    .image-generator textarea:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px var(--primary-light);
    }

    .image-generator textarea::placeholder {
        color: var(--gray-400);
        font-style: italic;
    }

    .generate-image-btn {
        background: linear-gradient(135deg, var(--accent) 0%, var(--accent-hover) 100%);
        color: white;
        border: none;
        padding: var(--spacing-md) var(--spacing-lg);
        border-radius: var(--border-radius-md);
        font-size: 0.9rem;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
        box-shadow: var(--shadow-md);
    }

    .generate-image-btn:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);
    }

    .generate-image-btn:active {
        transform: translateY(0);
    }

    .form-hint {
        font-size: 0.8rem;
        color: var(--gray-500);
        font-style: italic;
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
    }

    .form-hint i {
        color: var(--accent);
    }

    .image-preview {
        width: 100%;
        height: 120px;
        background: var(--gray-100);
        border-radius: var(--border-radius-md);
        overflow: hidden;
        border: 2px solid var(--gray-200);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all var(--transition-normal);
    }

    .image-preview:hover {
        border-color: var(--primary);
    }

    .image-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .empty-preview {
        color: var(--gray-400);
        text-align: center;
        font-size: 0.875rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-sm);
    }

    .empty-preview i {
        font-size: 1.5rem;
        opacity: 0.6;

        border-radius: var(--border-radius);
        overflow: hidden;
        border: 2px solid transparent;
        transition: all 0.3s;
    }

    /* ========== TEXT CONTROLS ========== */
    .text-controls-section {
        margin-bottom: var(--spacing-xl);
        padding: var(--spacing-lg);
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(5px);
        border-radius: var(--border-radius-lg);
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        transition: all var(--transition-normal);
    }

    .text-controls-section:hover {
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        transform: translateY(-1px);
    }

    .text-controls-section h4 {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        margin-bottom: var(--spacing-lg);
        font-size: 1.2rem;
        font-weight: 700;
        color: var(--dark);
        background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .text-controls-section h4 i {
        color: var(--primary);
        opacity: 0.8;
    }

    .control-group {
        margin-bottom: var(--spacing-lg);
        padding: var(--spacing-md);
        background: rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(5px);
        border-radius: var(--border-radius-md);
        border: 1px solid rgba(255, 255, 255, 0.4);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.03);
        transition: all var(--transition-normal);
    }

    .control-group:hover {
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        transform: translateY(-1px);
    }

    .control-group h5 {
        font-size: 1rem;
        font-weight: 700;
        color: var(--dark);
        margin-bottom: var(--spacing-md);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
    }

    .control-group h5 i {
        color: var(--primary);
        font-size: 0.8rem;
    }

    .control-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--spacing-md);
        margin-bottom: var(--spacing-md);
    }

    .control-row:last-child {
        margin-bottom: 0;
    }

    .control-item {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
    }

    .control-item label {
        font-size: 0.8rem;
        font-weight: 500;
        color: var(--gray-700);
    }

    .control-item input[type="color"] {
        width: 50px;
        height: 40px;
        border: 2px solid var(--gray-300);
        border-radius: var(--border-radius-md);
        cursor: pointer;
        transition: all var(--transition-normal);
    }

    .control-item input[type="color"]:hover {
        border-color: var(--primary);
        transform: scale(1.05);
    }

    .control-item input[type="range"] {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: var(--gray-200);
        outline: none;
        -webkit-appearance: none;
        appearance: none;
        cursor: pointer;
    }

    .control-item input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--primary);
        cursor: pointer;
        transition: all var(--transition-normal);
        box-shadow: var(--shadow-sm);
    }

    .control-item input[type="range"]::-webkit-slider-thumb:hover {
        background: var(--primary-hover);
        transform: scale(1.1);
        box-shadow: var(--shadow-md);
    }

    .control-item select {
        padding: var(--spacing-sm) var(--spacing-md);
        border: 2px solid var(--gray-300);
        border-radius: var(--border-radius-md);
        font-size: 0.8rem;
        background: var(--light);
        color: var(--dark);
        cursor: pointer;
        transition: all var(--transition-normal);
        font-family: var(--font-family-primary);
    }

    .control-item select:hover {
        border-color: var(--primary);
    }

    .control-item select:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px var(--primary-light);
    }

    .alignment-buttons {
        display: flex;
        gap: var(--spacing-xs);
    }

    .alignment-btn {
        flex: 1;
        padding: var(--spacing-sm);
        border: 2px solid var(--gray-300);
        border-radius: var(--border-radius-md);
        background: var(--light);
        color: var(--gray-600);
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        font-weight: 500;
    }

    .alignment-btn:hover {
        border-color: var(--primary);
        background: var(--primary-light);
        color: var(--primary);
    }

    .alignment-btn.active {
        border-color: var(--primary);
        background: var(--primary);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .weight-buttons {
        display: flex;
        gap: var(--spacing-xs);
    }

    .weight-btn {
        flex: 1;
        padding: var(--spacing-sm);
        border: 2px solid var(--gray-300);
        border-radius: var(--border-radius-md);
        background: var(--light);
        color: var(--gray-600);
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        font-weight: 500;
    }

    .weight-btn:hover {
        border-color: var(--primary);
        background: var(--primary-light);
        color: var(--primary);
    }

    .weight-btn.active {
        border-color: var(--primary);
        background: var(--primary);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .transform-buttons {
        display: flex;
        gap: var(--spacing-xs);
    }

    .transform-btn {
        flex: 1;
        padding: var(--spacing-sm);
        border: 2px solid var(--gray-300);
        border-radius: var(--border-radius-md);
        background: var(--light);
        color: var(--gray-600);
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        font-weight: 500;
        text-transform: capitalize;
    }

    .transform-btn:hover {
        border-color: var(--primary);
        background: var(--primary-light);
        color: var(--primary);
    }

    .transform-btn.active {
        border-color: var(--primary);
        background: var(--primary);
        color: white;
        box-shadow: var(--shadow-sm);
    }

    .slide-item-preview {
        height: 60px;
        background: white;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
        color: var(--gray);
        overflow: hidden;
    }

    .sidebar-section {
        margin-bottom: 1.5rem;
        padding-bottom: 1.5rem;
        border-bottom: 1px solid var(--light-gray);
    }

    .sidebar-section h4 {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 1rem;
        font-size: 0.875rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray);
    }

    .design-tools {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .tool-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .tool-group label {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--dark);
    }

    .tool-group input[type="color"] {
        width: 100%;
        height: 40px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
    }

    .tool-group select {
        padding: 0.5rem;
        border: 1px solid var(--light-gray);
        border-radius: 6px;
        font-size: 0.875rem;
    }

    .image-generator {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    #imagePrompt {
        width: 100%;
        min-height: 80px;
        padding: 0.75rem;
        border: 1px solid var(--light-gray);
        border-radius: 8px;
        resize: vertical;
        font-size: 0.875rem;
    }

    .image-preview {
        width: 100%;
        height: 120px;
        background: var(--light);
        border-radius: 8px;
        overflow: hidden;
        margin-top: 0.5rem;
    }

    .image-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    /* ========== SIDEBAR ACTIONS ========== */
    .sidebar-actions {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-md);
        margin-top: auto;
        padding-top: var(--spacing-xl);
        border-top: 2px solid var(--gray-200);
    }

    /* ========== MAIN EDITOR saystoryS ========== */
    .editor-main {
        display: flex;
        flex-direction: column;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: var(--border-radius-lg);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.2);
        transition: all var(--transition-normal);
    }

    .editor-main:hover {
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
    }

    .editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--spacing-lg) var(--spacing-xl);
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(5px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        position: relative;
    }

    .editor-header::before {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: linear-gradient(90deg, transparent, var(--primary), var(--accent), transparent);
        opacity: 0.6;
    }

    .editor-nav {
        display: flex;
        align-items: center;
        gap: var(--spacing-lg);
    }

    .editor-nav span {
        font-size: 1.1rem;
        font-weight: 700;
        color: var(--dark);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .editor-nav span i {
        color: var(--primary);
    }

    .editor-tools {
        display: flex;
        gap: var(--spacing-sm);
        flex-wrap: wrap;
    }

    .editor-tools button {
        background: var(--light);
        border: 2px solid var(--gray-200);
        color: var(--gray-600);
        padding: var(--spacing-sm) var(--spacing-md);
        border-radius: var(--border-radius-md);
        cursor: pointer;
        transition: all var(--transition-fast);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.875rem;
        font-weight: 500;
    }

    .editor-tools button:hover {
        border-color: var(--primary);
        color: var(--primary);
        background: var(--primary-light);
        transform: translateY(-1px);
    }

    .editor-tools button:active {
        transform: translateY(0);
    }

    .saystorys-container {
        flex: 1;
        background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        border-radius: 0;
        overflow: hidden;
        position: relative;
        min-height: 600px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.03);
    }

    #konvaContainer {
        width: 100%;
        height: 100%;
        background: white;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
        border-radius: var(--border-radius-md);
        margin: var(--spacing-md);
    }

    .empty-state {
        text-align: center;
        color: var(--gray-400);
        max-width: 400px;
        padding: var(--spacing-2xl);
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(10px);
        border-radius: var(--border-radius-lg);
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .empty-state i {
        font-size: 4rem;
        margin-bottom: var(--spacing-lg);
        opacity: 0.6;
        background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .empty-state h3 {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--dark);
        margin-bottom: var(--spacing-md);
    }

    .empty-state p {
        font-size: 1rem;
        color: var(--gray-500);
        line-height: 1.6;
    }

    /* ========== RIGHT PROPERTIES PANEL ========== */
    .editor-properties {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: var(--border-radius-lg);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: var(--spacing-xl);
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        transition: all var(--transition-normal);
    }

    .editor-properties:hover {
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
    }

    .editor-properties::-webkit-scrollbar {
        width: 8px;
    }

    .editor-properties::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.05);
        border-radius: 4px;
    }

    .editor-properties::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        transition: background var(--transition-fast);
    }

    .editor-properties::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.3);
    }

    .properties-header {
        margin-bottom: var(--spacing-xl);
        padding-bottom: var(--spacing-lg);
        border-bottom: 2px solid rgba(99, 102, 241, 0.1);
    }

    .properties-header h4 {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        margin: 0;
        font-size: 1.2rem;
        font-weight: 700;
        color: var(--dark);
        background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .properties-header h4 i {
        color: var(--primary);
        opacity: 0.8;
    }

    .properties-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xl);
    }

    .properties-section {
        padding: var(--spacing-lg);
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(5px);
        border-radius: var(--border-radius-lg);
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        transition: all var(--transition-normal);
    }

    .properties-section:hover {
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        transform: translateY(-1px);
    }

    .properties-section h5 {
        font-size: 1.1rem;
        font-weight: 700;
        color: var(--dark);
        margin-bottom: var(--spacing-lg);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        background: linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }

    .properties-section h5 i {
        color: var(--primary);
        font-size: 0.9rem;
        opacity: 0.8;
    }

    .form-group {
        margin-bottom: var(--spacing-lg);
    }

    .form-group label {
        display: block;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--gray-700);
        margin-bottom: var(--spacing-sm);
    }

    .form-control {
        width: 100%;
        padding: var(--spacing-md);
        border: 2px solid var(--gray-300);
        border-radius: var(--border-radius-md);
        font-size: 0.875rem;
        background: var(--light);
        color: var(--dark);
        transition: all var(--transition-normal);
        font-family: var(--font-family-primary);
    }

    .form-control:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px var(--primary-light);
    }

    .form-control::placeholder {
        color: var(--gray-400);
    }

    .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-md) var(--spacing-lg);
        border-radius: var(--border-radius-md);
        font-size: 0.875rem;
        font-weight: 600;
        text-decoration: none;
        cursor: pointer;
        transition: all var(--transition-normal);
        border: none;
        font-family: var(--font-family-primary);
        position: relative;
        overflow: hidden;
    }

    .btn-primary {
        background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
        color: white;
        box-shadow: 0 8px 24px rgba(99, 102, 241, 0.3);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 32px rgba(99, 102, 241, 0.4);
        background: linear-gradient(135deg, var(--primary-hover) 0%, var(--secondary-hover) 100%);
    }

    .btn-secondary {
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        color: var(--dark);
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }

    .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.95);
        border-color: var(--primary);
        color: var(--primary);
        transform: translateY(-1px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    }

    .btn-success {
        background: linear-gradient(135deg, var(--success) 0%, var(--success-hover) 100%);
        color: white;
        box-shadow: 0 8px 24px rgba(34, 197, 94, 0.3);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-success:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 32px rgba(34, 197, 94, 0.4);
    }

    .btn-warning {
        background: linear-gradient(135deg, var(--warning) 0%, var(--warning-hover) 100%);
        color: white;
        box-shadow: var(--shadow-md);
    }

    .btn-warning:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-lg);

        color: var(--dark);
    }

    .properties-content {
        flex: 1;
    }

    .properties-section {
        margin-bottom: 1.5rem;
        padding-bottom: 1.5rem;
        border-bottom: 1px solid var(--light-gray);
    }

    .properties-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
    }

    .properties-section h5 {
        margin-bottom: 1rem;
        font-size: 0.875rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray);
        font-weight: 600;
    }

    .form-group {
        margin-bottom: 1rem;
    }

    .form-group label {
        display: block;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--dark);
    }

    .form-control {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid var(--light-gray);
        border-radius: 6px;
        font-size: 0.875rem;
        transition: border-color 0.3s;
    }

    .form-control:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .form-hint {
        font-size: 0.75rem;
        color: var(--gray);
        margin-top: 0.25rem;
    }

    .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 6px;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
    }

    .btn-primary {
        background: var(--primary);
        color: white;
    }

    .btn-primary:hover {
        background: var(--primary-dark);
        transform: translateY(-1px);
    }

    .btn-secondary {
        background: var(--light);
        color: var(--dark);
        border: 1px solid var(--light-gray);
    }

    .btn-secondary:hover {
        background: var(--light-gray);
    }

    .btn-success {
        background: var(--success);
        color: white;
    }

    .btn-success:hover {
        background: #059669;
    }

    .btn-warning {
        background: #f59e0b;
        color: white;
    }

    .btn-warning:hover {
        background: #d97706;
    }

    /* Result Page */
    .result-container {
        max-width: 1200px;
        margin: 2rem auto;
        padding: 2rem;
        background: white;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-lg);
    }

    .result-header {
        text-align: center;
        padding: 3rem;
        border-radius: var(--border-radius);
        margin-bottom: 2rem;
    }

    .result-header.success {
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05));
        color: var(--success);
    }

    .result-header i {
        font-size: 4rem;
        margin-bottom: 1rem;
    }

    .result-actions {
        display: flex;
        justify-content: center;
        gap: 1rem;
        margin-bottom: 3rem;
        flex-wrap: wrap;
    }

    .slides-preview {
        margin-bottom: 3rem;
    }

    .slides-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 1.5rem;
        margin-top: 1.5rem;
    }

    .slide-card {
        background: var(--light);
        border-radius: var(--border-radius);
        overflow: hidden;
        box-shadow: var(--shadow);
    }

    .slide-number {
        padding: 0.75rem;
        background: var(--primary);
        color: white;
        font-weight: 600;
        text-align: center;
    }

    .slide-preview {
        padding: 1.5rem;
        min-height: 200px;
    }

    .slide-preview h3 {
        margin-bottom: 0.75rem;
        font-size: 1.125rem;
    }

    .slide-preview p {
        color: var(--gray);
        font-size: 0.875rem;
        line-height: 1.5;
    }

    .slide-actions {
        display: flex;
        gap: 0.5rem;
        padding: 1rem;
        background: white;
        border-top: 1px solid var(--light-gray);
    }

    .result-tips {
        padding: 2rem;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
        border-radius: var(--border-radius);
    }

    .tips-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.5rem;
        margin-top: 1.5rem;
    }

    .tip {
        text-align: center;
        padding: 1.5rem;
        background: white;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
    }

    .tip i {
        font-size: 2rem;
        color: var(--primary);
        margin-bottom: 1rem;
    }

    /* Toastr Customization */
    .toast-success {
        background-color: var(--success) !important;
        background-repeat: no-repeat !important;
        background-position: 15px center !important;
    }

    .toast-error {
        background-color: var(--error) !important;
        background-repeat: no-repeat !important;
        background-position: 15px center !important;
    }

    /* Responsive Editor */
    @media (max-width: 1024px) {
        .editor-container {
            grid-template-columns: 1fr;
        }

        .editor-sidebar {
            border-right: none;
            border-bottom: 1px solid var(--light-gray);
        }
    }

    /* Error message */
    .error-message {
        grid-column: 1 / -1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 500px;
        background: white;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
    }

    .error-content {
        text-align: center;
        padding: 3rem;
    }

    /* ========== RESPONSIVE DESIGN ========== */
    @media (max-width: 1200px) {
        .editor-container {
            grid-template-columns: 280px 1fr 320px;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
        }
    }

    @media (max-width: 1024px) {
        .editor-container {
            grid-template-columns: 260px 1fr 300px;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
        }

        .sidebar-section,
        .properties-section,
        .text-controls-section {
            padding: var(--spacing-md);
        }

        .control-row {
            grid-template-columns: 1fr;
            gap: var(--spacing-sm);
        }
    }

    @media (max-width: 768px) {
        .editor-container {
            grid-template-columns: 1fr;
            grid-template-rows: auto 1fr auto;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
        }

        .editor-sidebar,
        .editor-properties {
            display: none;
        }

        .editor-main {
            grid-row: 2;
            margin: 0;
        }

        .editor-header {
            padding: var(--spacing-md) var(--spacing-lg);
        }

        .editor-nav {
            flex-direction: column;
            gap: var(--spacing-sm);
            align-items: stretch;
        }

        .editor-nav span {
            justify-content: center;
            font-size: 1rem;
        }

        .editor-tools {
            justify-content: center;
            flex-wrap: wrap;
        }

        .saystorys-container {
            min-height: 400px;
        }

        #konvaContainer {
            margin: var(--spacing-sm);
        }
    }

    @media (max-width: 480px) {
        .editor-container {
            padding: var(--spacing-sm);
            gap: var(--spacing-sm);
        }

        .editor-header {
            padding: var(--spacing-sm) var(--spacing-md);
            flex-direction: column;
            gap: var(--spacing-md);
            align-items: stretch;
        }

        .editor-nav {
            flex-direction: row;
            justify-content: space-between;
        }

        .editor-tools {
            justify-content: center;
            gap: var(--spacing-xs);
        }

        .editor-tools button {
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: 0.75rem;
        }

        .saystorys-container {
            min-height: 300px;
        }

        .empty-state {
            padding: var(--spacing-lg);
            max-width: 300px;
        }

        .empty-state i {
            font-size: 3rem;
        }

        .empty-state h3 {
            font-size: 1.25rem;
        }
    }

    .error-content i {
        font-size: 4rem;
        color: var(--warning);
        margin-bottom: 1.5rem;
    }

    .error-content h2 {
        color: var(--dark);
        margin-bottom: 1.5rem;
    }

    /* saystorys container adjustments */
    .saystorys-container {
        position: relative;
        background: white;
        border-radius: var(--border-radius);
        overflow: hidden;
        box-shadow: var(--shadow);
        min-height: 500px;
    }

    /* ========== LAYOUT NAVBAR ========== */
    .layout-navbar {
        display: flex;
        overflow-x: auto;
        gap: var(--spacing-sm);
        padding: var(--spacing-sm) 0;
        margin-bottom: var(--spacing-md);
        scrollbar-width: none;
        /* Firefox */
        -ms-overflow-style: none;
        /* IE 10+ */
        align-items: center;
    }

    .layout-navbar::-webkit-scrollbar {
        display: none;
        /* Chrome/Safari */
    }

    .layout-chip {
        flex: 0 0 auto;
        padding: 8px 16px;
        border: 1px solid var(--gray-300);
        background: white;
        border-radius: 50px;
        /* Pill shape */
        font-size: 0.85rem;
        font-weight: 500;
        color: var(--gray-600);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02);
    }

    .layout-chip:hover {
        border-color: var(--primary);
        color: var(--primary);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
    }

    .layout-chip.active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
        box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
    }

    .layout-chip i {
        font-size: 0.9em;
    }
</style>
{% endblock %}

{% block content %}
<div class="editor-container">
    {% if error %}
    <div class="error-message">
        <div class="error-content">
            <i class="fas fa-exclamation-triangle"></i>
            <h2>{{ error }}</h2>
            <a href="/" class="btn btn-primary">
                <i class="fas fa-home"></i> Go to Homepage
            </a>
        </div>
    </div>
    {% else %}
    <!-- Sidebar -->
    <div class="editor-sidebar">
        <div class="sidebar-header">
            <h3><i class="fas fa-layer-group"></i> Slides</h3>
        </div>

        <div class="slides-list" id="slidesList">
            <!-- Slides will be loaded dynamically -->
            <div class="loading-slides">
                <div class="loading-spinner small"></div>
                <p>Loading slides...</p>
            </div>
        </div>

        <!-- Slide Action Buttons -->
        <div style="display: flex; gap: 8px; margin-top: 12px; margin-bottom: 16px;">
            <button id="addSlide" class="btn btn-secondary" style="flex: 1;">
                <i class="fas fa-plus"></i> Add Slide
            </button>
        </div>

        <div class="sidebar-section">
            <h4><i class="fas fa-paint-brush"></i> Design Tools</h4>
            <div class="design-tools">
                <div class="tool-group">
                    <label>Background</label>
                    <input type="color" id="bgColor" value="#FFFFFF">
                </div>
                <div class="tool-group">
                    <label>Font Color</label>
                    <input type="color" id="fontColor" value="#000000">
                </div>
                <div class="tool-group">
                    <label>Font Family</label>
                    <select id="fontFamily">
                        <option value="Arial">Arial</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Poppins" selected>Poppins</option>
                        <option value="Inter">Inter</option>
                        <option value="Montserrat">Montserrat</option>
                    </select>
                </div>
                <div class="tool-group">
                    <label>Layout</label>
                    <select id="layout">
                        <option value="centered" selected>Centered</option>
                        <option value="left">Left Aligned</option>
                        <option value="split">Split Screen</option>
                        <option value="top">Top Aligned</option>
                    </select>
                </div>
                <div class="tool-group mt-3" style="display:none;">
                    <div class="form-hint small mt-1">Based on slide description</div>
                </div>
            </div>
        </div>

        <div class="sidebar-section">
            <h4><i class="fas fa-image"></i> Generate Image</h4>
            <div class="image-generator">
                <textarea id="imagePrompt"
                    placeholder="Describe the background image you want to generate..."></textarea>
                <button id="generateImageBtn" class="btn btn-secondary">
                    <i class="fas fa-magic"></i> Generate & Apply
                </button>
                <div class="form-hint">Image will be applied to current slide</div>
                <div id="imagePreview" class="image-preview">
                    <div class="empty-preview">
                        <i class="fas fa-image"></i>
                        <p>Generated image will appear here</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar-actions">
            <button id="exportSlideBtn" class="btn btn-primary">
                <i class="fas fa-download"></i> Export Current Slide
            </button>
            <button id="exportBtn" class="btn btn-success">
                <i class="fas fa-download"></i> Export All
            </button>
        </div>
    </div>

    <!-- Main Editor - Center saystorys -->
    <div class="editor-main">
        <!-- Layout Navbar (Relocated to Top) -->
        <div class="layout-navbar mb-3" id="layoutVibeGroup" style="padding: 10px 0; background: transparent;">
            <button type="button" class="layout-chip active layout-vibe-btn" data-vibe="corporate">
                <i class="fas fa-briefcase"></i> Corporate
            </button>
            <button type="button" class="layout-chip layout-vibe-btn" data-vibe="minimal">
                <i class="fas fa-seedling"></i> Minimal
            </button>
            <button type="button" class="layout-chip layout-vibe-btn" data-vibe="card">
                <i class="fas fa-layer-group"></i> Card
            </button>
            <button type="button" class="layout-chip layout-vibe-btn" data-vibe="split">
                <i class="fas fa-columns"></i> Split
            </button>
            <button type="button" class="layout-chip layout-vibe-btn" data-vibe="gradient">
                <i class="fas fa-wind"></i> Gradient
            </button>
            <button type="button" class="layout-chip layout-vibe-btn" data-vibe="geometric">
                <i class="fas fa-shapes"></i> Geometric
            </button>
            <button type="button" class="layout-chip layout-vibe-btn" data-vibe="magazine">
                <i class="fas fa-newspaper"></i> Magazine
            </button>
            <button type="button" class="layout-chip layout-vibe-btn" data-vibe="creative">
                <i class="fas fa-paint-splash"></i> Creative
            </button>
            <button type="button" class="layout-chip layout-vibe-btn" data-vibe="neon">
                <i class="fas fa-bolt"></i> Neon
            </button>
        </div>

        <div class="editor-header">
            <div class="editor-nav">
                <button id="prevSlide" class="btn btn-sm">
                    <i class="fas fa-chevron-left"></i> Previous
                </button>
                <span id="currentSlide">Slide <span id="currentSlideNumber">1</span> of <span
                        id="totalSlides">0</span></span>
                <button id="nextSlide" class="btn btn-sm">
                    Next <i class="fas fa-chevron-right"></i>
                </button>
            </div>
            <div class="editor-tools">
                <button id="undo" class="btn btn-sm" title="Undo">
                    <i class="fas fa-undo"></i>
                </button>

                <button id="fullscreen" class="btn btn-sm" title="Fullscreen">
                    <i class="fas fa-expand-arrows-alt"></i>
                </button>
            </div>
        </div>

        <div class="saystorys-container">
            <div id="konvaContainer"></div>
            <div id="emptyState" class="empty-state">
                <i class="fas fa-layer-group"></i>
                <h3>No Slides Loaded</h3>
                <p>Generate a carousel first or load existing slides</p>
            </div>
        </div>
    </div>

    <!-- Right Properties Panel -->
    <div class="editor-properties">
        <div class="properties-header">
            <h4><i class="fas fa-edit"></i> Edit Content</h4>
        </div>

        <div class="properties-content">
            <!-- MAGIC ADAPT SECTION -->
            <!-- <div class="properties-section"
                style="background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(168, 85, 247, 0.1) 100%); border: 1px solid rgba(99, 102, 241, 0.2);">
                <h5 style="color: var(--primary);"><i class="fas fa-magic"></i> Magic Content Adapt</h5>
                <div class="form-group">
                    <label class="small text-muted mb-1">Select Layout Vibe</label>
                    <select id="adaptLayoutSelect" class="form-select form-select-sm shadow-sm border-primary">
                        <option value="Split Screen">Split Screen (Bold & Short)</option>
                        <option value="Creative Chaos">Creative Chaos (Playful)</option>
                        <option value="Corporate Pro">Corporate Pro (Formal)</option>
                        <option value="Minimal Clean">Minimal Clean (Elegant)</option>
                        <option value="Gradient Flow">Gradient Flow (SaaS/Modern)</option>
                        <option value="Neon Glow">Neon Glow (Futuristic)</option>
                        <option value="Geometric Pro">Geometric Pro (Structured)</option>
                        <option value="Magazine Style">Magazine Style (Editorial)</option>
                        <option value="Card Layout">Card Layout (Modular)</option>
                        <option value="Sidebar Focus">Sidebar Focus (Narrative)</option>
                    </select>
                </div>
                <button id="adaptContentBtn" class="btn btn-primary btn-sm w-100 mt-2">
                    <i class="fas fa-wand-magic-sparkles"></i> Adapt Content to Layout
                </button>
            </div> -->

            <div class="properties-section">
                <h5>Slide Details</h5>
                <div class="form-group mb-4">
                    <label class="form-label fw-bold">Title</label>
                    <input type="text" id="slideTitle" placeholder="Enter title" class="form-control">

                    <button class="btn btn-light btn-sm w-100 mt-1 text-muted border-0" type="button"
                        onclick="toggleControls('titleControlsPanel', this)"
                        style="border-radius: 0 0 6px 6px; font-size: 0.8rem;">
                        <i class="fas fa-sliders-h me-1"></i> Edit Styles <i class="fas fa-chevron-down ms-1"></i>
                    </button>

                    <!-- Title Controls (Collapsible) -->
                    <div id="titleControlsPanel"
                        class="control-group mt-2 ps-2 pe-2 border-start border-3 border-primary"
                        style="display:none; background: #fff;">

                        <div class="d-flex align-items-center justify-content-between mb-3 pt-2">
                            <label class="small text-muted mb-0">Color</label>
                            <input type="color" id="titleColor" class="form-control form-control-color shadow-sm"
                                value="#000000" title="Choose color" style="width: 60px;">
                        </div>

                        <div class="mb-3">
                            <div class="d-flex justify-content-between mb-1">
                                <label class="small text-muted">Size</label>
                                <span class="small text-muted" id="titleFontSizeDisplay">32px</span>
                            </div>
                            <input type="range" id="titleFontSize" min="16" max="72" value="32" step="2"
                                class="form-range"
                                oninput="document.getElementById('titleFontSizeDisplay').textContent = this.value + 'px'">
                        </div>

                        <div class="mb-3">
                            <label class="small text-muted mb-1 d-block">Font Family</label>
                            <select id="titleFontFamily" class="form-select form-select-sm shadow-sm">
                                <option value="Arial">Arial</option>
                                <option value="Helvetica">Helvetica</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Poppins" selected>Poppins</option>
                                <option value="Inter">Inter</option>
                                <option value="Montserrat">Montserrat</option>
                                <option value="Roboto">Roboto</option>
                                <option value="Open Sans">Open Sans</option>
                            </select>
                        </div>

                        <div class="mb-3">
                            <label class="small text-muted mb-1 d-block">Style</label>
                            <div class="btn-group w-100 shadow-sm" role="group">
                                <button type="button" class="btn btn-outline-secondary btn-sm title-weight-btn"
                                    data-weight="bold"><i class="fas fa-bold"></i></button>
                                <button type="button" class="btn btn-outline-secondary btn-sm title-style-btn"
                                    data-style="italic"><i class="fas fa-italic"></i></button>
                                <button type="button" class="btn btn-outline-secondary btn-sm title-decoration-btn"
                                    data-decoration="underline"><i class="fas fa-underline"></i></button>
                            </div>
                        </div>

                        <div class="mb-2 pb-2">
                            <label class="small text-muted mb-1 d-block">Alignment</label>
                            <div class="alignment-buttons btn-group w-100 shadow-sm" role="group">
                                <button type="button" class="btn btn-outline-secondary btn-sm title-alignment-btn"
                                    data-align="left">
                                    <i class="fas fa-align-left"></i>
                                </button>
                                <button type="button"
                                    class="btn btn-outline-secondary btn-sm title-alignment-btn active"
                                    data-align="center">
                                    <i class="fas fa-align-center"></i>
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm title-alignment-btn"
                                    data-align="right">
                                    <i class="fas fa-align-right"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="form-group mb-4">
                    <label class="form-label fw-bold">Description</label>
                    <textarea id="slideDescription" placeholder="Enter description" rows="3"
                        class="form-control"></textarea>

                    <button class="btn btn-light btn-sm w-100 mt-1 text-muted border-0" type="button"
                        onclick="toggleControls('descriptionControlsPanel', this)"
                        style="border-radius: 0 0 6px 6px; font-size: 0.8rem;">
                        <i class="fas fa-sliders-h me-1"></i> Edit Styles <i class="fas fa-chevron-down ms-1"></i>
                    </button>

                    <!-- Description Controls (Collapsible) -->
                    <div id="descriptionControlsPanel"
                        class="control-group mt-2 ps-2 pe-2 border-start border-3 border-secondary"
                        style="display:none; background: #fff;">

                        <div class="d-flex align-items-center justify-content-between mb-3 pt-2">
                            <label class="small text-muted mb-0">Color</label>
                            <input type="color" id="descriptionColor" class="form-control form-control-color shadow-sm"
                                value="#333333" style="width: 60px;">
                        </div>

                        <div class="mb-3">
                            <div class="d-flex justify-content-between mb-1">
                                <label class="small text-muted">Size</label>
                                <span class="small text-muted" id="descriptionFontSizeDisplay">18px</span>
                            </div>
                            <input type="range" id="descriptionFontSize" min="12" max="48" value="18" step="1"
                                class="form-range"
                                oninput="document.getElementById('descriptionFontSizeDisplay').textContent = this.value + 'px'">
                        </div>

                        <div class="mb-3">
                            <label class="small text-muted mb-1 d-block">Font Family</label>
                            <select id="descriptionFontFamily" class="form-select form-select-sm shadow-sm">
                                <option value="Arial">Arial</option>
                                <option value="Helvetica">Helvetica</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Poppins" selected>Poppins</option>
                                <option value="Inter">Inter</option>
                                <option value="Montserrat">Montserrat</option>
                                <option value="Roboto">Roboto</option>
                                <option value="Open Sans">Open Sans</option>
                            </select>
                        </div>

                        <div class="mb-3">
                            <label class="small text-muted mb-1 d-block">Style</label>
                            <div class="btn-group w-100 shadow-sm" role="group">
                                <button type="button" class="btn btn-outline-secondary btn-sm description-weight-btn"
                                    data-weight="bold"><i class="fas fa-bold"></i></button>
                                <button type="button" class="btn btn-outline-secondary btn-sm description-style-btn"
                                    data-style="italic"><i class="fas fa-italic"></i></button>
                                <button type="button"
                                    class="btn btn-outline-secondary btn-sm description-decoration-btn"
                                    data-decoration="underline"><i class="fas fa-underline"></i></button>
                            </div>
                        </div>

                        <div class="mb-2 pb-2">
                            <label class="small text-muted mb-1 d-block">Alignment</label>
                            <div class="alignment-buttons btn-group w-100 shadow-sm" role="group">
                                <button type="button" class="btn btn-outline-secondary btn-sm description-alignment-btn"
                                    data-align="left">
                                    <i class="fas fa-align-left"></i>
                                </button>
                                <button type="button"
                                    class="btn btn-outline-secondary btn-sm description-alignment-btn active"
                                    data-align="center">
                                    <i class="fas fa-align-center"></i>
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm description-alignment-btn"
                                    data-align="right">
                                    <i class="fas fa-align-right"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label">Extra Text</label>

                    <button id="addExtraTextBtn" class="btn btn-secondary w-100 mb-2">
                        <i class="fas fa-plus"></i> Add Text Block
                    </button>
                    <div class="form-hint">Double click text on saystorys to edit content</div>

                    <!-- Selected Text Controls (Dynamic) -->
                    <!-- Selected Text Controls (Dynamic) -->
                    <div id="selectedTextControls" class="form-group mb-4" style="display:none;">
                        <button id="selectedTextToggleBtn"
                            class="btn btn-light btn-sm w-100 mt-1 text-muted border-0 text-start text-truncate"
                            type="button" onclick="toggleControls('selectedControlsPanel', this)"
                            style="border-radius: 6px; font-size: 0.8rem;">
                            <i class="fas fa-sliders-h me-1"></i> <span id="selectedTextLabel">Selected Text</span> <i
                                class="fas fa-chevron-down float-end mt-1"></i>
                        </button>

                        <div id="selectedControlsPanel"
                            class="control-group mt-2 ps-2 pe-2 border-start border-3 border-danger"
                            style="display:none; background: #fff;">

                            <div class="d-flex align-items-center justify-content-between mb-3 pt-2">
                                <label class="small text-muted mb-0">Color</label>
                                <input type="color" id="selectedColor" class="form-control form-control-color shadow-sm"
                                    value="#000000" style="width: 60px;">
                            </div>

                            <div class="mb-3">
                                <div class="d-flex justify-content-between mb-1">
                                    <label class="small text-muted">Size</label>
                                    <span class="small text-muted" id="selectedFontSizeDisplay">24px</span>
                                </div>
                                <input type="range" id="selectedFontSize" min="12" max="120" value="24" step="1"
                                    class="form-range"
                                    oninput="document.getElementById('selectedFontSizeDisplay').textContent = this.value + 'px'">
                            </div>

                            <div class="mb-3">
                                <label class="small text-muted mb-1 d-block">Font Family</label>
                                <select id="selectedFontFamily" class="form-select form-select-sm shadow-sm">
                                    <option value="Arial">Arial</option>
                                    <option value="Helvetica">Helvetica</option>
                                    <option value="Georgia">Georgia</option>
                                    <option value="Poppins">Poppins</option>
                                    <option value="Inter">Inter</option>
                                    <option value="Montserrat">Montserrat</option>
                                    <option value="Roboto">Roboto</option>
                                    <option value="Open Sans">Open Sans</option>
                                </select>
                            </div>

                            <div class="mb-3">
                                <label class="small text-muted mb-1 d-block">Style</label>
                                <div class="btn-group w-100 shadow-sm" role="group">
                                    <button type="button" class="btn btn-outline-secondary btn-sm selected-weight-btn"
                                        data-weight="bold"><i class="fas fa-bold"></i></button>
                                    <button type="button" class="btn btn-outline-secondary btn-sm selected-style-btn"
                                        data-style="italic"><i class="fas fa-italic"></i></button>
                                    <button type="button"
                                        class="btn btn-outline-secondary btn-sm selected-decoration-btn"
                                        data-decoration="underline"><i class="fas fa-underline"></i></button>
                                </div>
                            </div>
                            <button id="deleteSelectedElementBtn" class="btn btn-outline-danger btn-sm w-100">
                                <i class="fas fa-trash me-2"></i> Delete Element
                            </button>
                        </div>
                    </div>
                </div>

                <!-- General Text Settings (Merged) -->
                <div class="form-group border-top pt-3 mt-3">
                    <label class="form-label fw-bold mb-3"><i class="fas fa-sliders-h"></i> General Text
                        Settings</label>
                    <div class="d-flex gap-2 mb-3">
                        <div class="flex-grow-1">
                            <label class="small text-muted mb-1">Line Height</label>
                            <input type="range" id="lineHeight" min="0.8" max="2.0" value="1.2" step="0.1"
                                class="form-range">
                        </div>
                        <div class="flex-grow-1">
                            <label class="small text-muted mb-1">Letter Spacing</label>
                            <input type="range" id="letterSpacing" min="-2" max="10" value="0" step="0.5"
                                class="form-range">
                        </div>
                    </div>
                    <div class="mb-2">
                        <label class="small text-muted mb-1 d-block">Text Transform</label>
                        <div class="transform-buttons btn-group w-100 shadow-sm">
                            <button type="button" class="btn btn-outline-secondary btn-sm transform-btn active"
                                data-transform="none">None</button>
                            <button type="button" class="btn btn-outline-secondary btn-sm transform-btn"
                                data-transform="uppercase">AA</button>
                            <button type="button" class="btn btn-outline-secondary btn-sm transform-btn"
                                data-transform="lowercase">aa</button>
                            <button type="button" class="btn btn-outline-secondary btn-sm transform-btn"
                                data-transform="capitalize">Aa</button>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Upload Image Section (Replaces AI Generation) -->
            <!-- Upload Image Section -->
            <div class="properties-section">
                <h5>Upload Image</h5>
                <div class="form-group">
                    <label class="form-label mb-2">Add Image to Slide</label>
                    <div class="d-flex gap-2 align-items-center">
                        <input type="file" id="imageUploadInput" accept="image/*" class="form-control form-control-sm"
                            style="display: none;">
                        <button id="uploadImageBtn" class="btn btn-light btn-sm w-100 border">
                            <i class="fas fa-plus"></i> Add Image
                        </button>
                    </div>
                    <div class="form-hint mt-1">Supported formats: PNG, JPG</div>
                </div>
            </div>


            <div class="properties-section">
                <h5>saystorys Settings</h5>
                <div class="form-group">
                    <label>Width (px)</label>
                    <input type="number" id="saystorysWidth" placeholder="1080" class="form-control" min="100"
                        max="4000">
                </div>
                <div class="form-group">
                    <label>Height (px)</label>
                    <input type="number" id="saystorysHeight" placeholder="1080" class="form-control" min="100"
                        max="4000">
                </div>
                <button id="updatesaystorysSize" class="btn btn-secondary">
                    <i class="fas fa-expand"></i> update Canvas
                </button>
            </div>





            <div class="properties-section">
                <h5>Platform Templates</h5>
                <div class="form-group">
                    <label>Platform</label>
                    <select id="platformSelect" class="form-control">
                        <option value="instagram">Instagram</option>
                        <option value="linkedin">LinkedIn</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Format</label>
                    <select id="formatSelect" class="form-control">
                        <option value="square">Square (1:1)</option>
                        <option value="portrait">Portrait (4:5)</option>
                        <option value="story">Story (9:16)</option>
                        <option value="landscape">Landscape (1.91:1)</option>
                    </select>
                </div>
                <button id="applyTemplate" class="btn btn-secondary">
                    <i class="fas fa-magic"></i> Apply Template
                </button>
            </div>
        </div>
    </div>


    {% endif %}
</div>

<!-- Loading overlay -->
<div id="editorLoading" class="loading-overlay" style="display: none;">
    <div class="loading-content">
        <div class="loading-spinner"></div>
        <h3>Loading Editor</h3>
        <p>Preparing your carousel for editing...</p>
        <div class="progress-bar">
            <div class="progress"></div>
        </div>
    </div>
</div>

<!-- CSRF Token -->
{% csrf_token %}
{% endblock %}

{% block extra_js %}
<script src="https://unpkg.com/konva@8/konva.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
    // CSRF Token helper
    function getCSRFToken() {
        return document.querySelector('[name=csrfmiddlewaretoken]').value;
    }

    // Toggle controls helper
    function toggleControls(panelId, btn) {
        const panel = document.getElementById(panelId);
        if (panel) {
            const isHidden = panel.style.display === 'none';
            panel.style.display = isHidden ? 'block' : 'none';

            // Update icon if button provided
            if (btn) {
                const icon = btn.querySelector('.fa-chevron-down') || btn.querySelector('.fa-chevron-up');
                if (icon) {
                    icon.classList.remove(isHidden ? 'fa-chevron-down' : 'fa-chevron-up');
                    icon.classList.add(isHidden ? 'fa-chevron-up' : 'fa-chevron-down');
                }
            }
        }
    }

    class CarouselEditor {
        constructor(projectId) {
            this.stage = null;
            this.layer = null;
            this.currentSlide = 0;
            this.slides = [];
            this.projectId = projectId;
            this.isLoading = true;
            this.undoStack = [];
            this.redoStack = [];
            this.scale = 1;
            this.autoSaveTimeout = null;
            this.isInitialized = false;
            this.activeTextTarget = null; // Stores the name of the currently selected text node for styling
        }

        debouncedSave() {
            clearTimeout(this.autoSaveTimeout);
            this.autoSaveTimeout = setTimeout(async () => {
                await this.saveCurrentSlideContent();
            }, 1000);
        }

        async initialize() {
            await this.init();
        }

        getIconsForText(text, max = 3) {
            if (!text) return [];
            const lowerText = text.toLowerCase();

            // Expanded Map for 'WOW' factor
            const map = {
                // Business & Growth
                'growth': '', 'trend': '', 'up': '', 'chart': '', 'data': '', 'stats': '',
                'money': '', 'cash': '', 'profit': '', 'sales': '', 'dollar': '', 'price': '',
                'target': '', 'goal': '', 'aim': '', 'focus': '', 'success': '', 'win': '',
                'trophy': '', 'first': '', 'leader': '', 'king': '', 'boss': '', 'work': '',
                'job': '', 'career': '', 'office': '', 'company': '', 'startup': '', 'launch': '',
                'ship': '', 'fast': '', 'quick': '', 'speed': '', 'bolt': '', 'power': '',

                // Tech & Digital
                'code': '', 'developer': '', 'coding': '', 'laptop': '', 'computer': '',
                'phone': '', 'mobile': '', 'app': '', 'screen': '', 'monitor': '',
                'network': '', 'internet': '', 'web': '', 'wifi': '', 'cloud': '',
                'server': '', 'save': '', 'database': '', 'robot': '', 'ai': '', 'bot': '',
                'tech': '', 'tool': '', 'fix': '', 'build': '', 'settings': '', 'gear': '',
                'lock': '', 'secure': '', 'security': '', 'shield': '', 'key': '', 'unlock': '',

                // Communication
                'email': '', 'mail': '', 'letter': '', 'message': '', 'chat': '', 'talk': '',
                'speak': '', 'community': '', 'team': '', 'group': '', 'users': '', 'people': '',
                'user': '', 'profile': '', 'person': '', 'call': '', 'phone': '', 'contact': '',
                'book': '', 'read': '', 'learn': '', 'study': '', 'write': '', 'edit': '',

                // Creative & Ideation
                'idea': '', 'light': '', 'think': '', 'mind': '', 'brain': '', 'smart': '',
                'genius': '', 'magic': '', 'sparkle': '', 'star': '', 'favorite': '', 'best': '',
                'art': '', 'design': '', 'paint': '', 'color': '', 'music': '', 'sound': '',
                'video': '', 'movie': '', 'film': '', 'photo': '', 'camera': '', 'image': '',

                // Time & Planning
                'time': '', 'clock': '', 'hour': '', 'wait': '', 'date': '', 'calendar': '',
                'plan': '', 'list': '', 'note': '', 'schedule': '', 'event': '', 'party': '',
                'celebrate': '', 'birthday': '', 'new': '', 'update': '', 'refresh': '',

                // Emotions & Vibes
                'love': '', 'heart': '', 'like': '', 'thumbs': '', 'good': '', 'great': '',
                'bad': '', 'hate': '', 'broken': '', 'stop': '', 'no': '', 'cancel': '',
                'yes': '', 'check': '', 'done': '', 'ok': '', 'cool': '', 'happy': '',
                'sad': '', 'cry': '', 'angry': '', 'fire': '', 'hot': '', 'burn': '',
                'water': '', 'drop': '', 'ocean': '', 'sun': '', 'sunny': '', 'moon': '',
                'night': '', 'planet': '', 'world': '', 'globe': '', 'travel': '', 'fly': '',
                'plane': '', 'car': '', 'drive': '', 'location': '', 'pin': '', 'map': '',
                'home': '', 'house': '', 'shop': '', 'buy': '', 'store': '', 'cart': ''
            };

            const simpleWords = lowerText.split(/[\s\n\r]+/);
            const foundIcons = new Set();

            // 2-pass scan: First specific match, then substring match
            for (const word of simpleWords) {
                if (foundIcons.size >= max) break;
                // Remove punctuation
                const clean = word.replace(/[.,/#!$%^&*;:{}=\-_`~()?"']/g, "");
                // Exact match (including mapped synonyms)
                if (map[clean]) {
                    foundIcons.add(map[clean]);
                }
            }

            // Fallback: If minimal icons found, try finding keys WITHIN words (e.g. "security" -> matches key "secure"?) 
            // - Simplified for performance: Just ensure we have at least 1 if possible.

            return Array.from(foundIcons);
        }

        getIllustration(text) {
            const icons = this.getIconsForText(text, 1);
            return icons.length > 0 ? icons[0] : null;
        }

        async adaptContent() {
            const layoutStyle = document.getElementById('adaptLayoutSelect').value;
            const btn = document.getElementById('adaptContentBtn');
            const slide = this.slides[this.currentSlide];

            if (!slide) return;

            // UI Loading State
            console.log(' Starting adaptation process...');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adapting...';
            btn.disabled = true;

            try {
                console.log('Sending request to /api/adapt-content/', {
                    slide_id: slide.id,
                    layout_style: layoutStyle
                });
                const response = await fetch('/api/adapt-content/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify({
                        slide_id: slide.id,
                        layout_style: layoutStyle
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Update local data
                    slide.title = data.title;
                    slide.description = data.description;
                    if (data.layout) {
                        slide.layout = data.layout;
                    }

                    // Update Inputs
                    const titleInput = document.getElementById('slideTitle');
                    const descInput = document.getElementById('slideDescription');
                    const layoutInput = document.getElementById('layout');

                    if (titleInput) titleInput.value = data.title;
                    if (descInput) descInput.value = data.description;
                    if (layoutInput && data.layout) layoutInput.value = data.layout;

                    // Re-render
                    this.renderSlide(this.currentSlide);

                    toastr.success(`Content adapted to ${layoutStyle} style!`);

                    // --- CHAINED IMAGE GENERATION ---
                    // Automatically generate image if requested
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating Image...';

                    // Use prompt or title as description
                    const prompt = slide.image_prompt || `Professional ${slide.title} background for ${layoutStyle}`;
                    await this.generateImageForSlide(slide, prompt, false); // false = don't show specific image success toast again if we want, but let's keep it

                } else {
                    toastr.error(data.error || 'Failed to adapt content');
                }
            } catch (error) {
                console.error('Error adapting content:', error);
                toastr.error('Network error during adaptation');
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        async generateImageForSlide(slide, prompt, showSuccessToast = true) {
            const slideIndex = this.slides.findIndex(s => s.id === slide.id);

            try {
                const response = await fetch('/api/generate-and-apply/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify({
                        description: prompt,
                        slide_id: slide.id,
                        platform: 'instagram'
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Update slide with generated image
                    this.slides[slideIndex].generated_image = data.filename;
                    this.slides[slideIndex].image_prompt = prompt;

                    // Update UI if current slide
                    if (this.currentSlide === slideIndex) {
                        const promptInput = document.getElementById('slideImagePrompt');
                        if (promptInput) promptInput.value = prompt;

                        const imagePreview = document.getElementById('imagePreview');
                        if (imagePreview) imagePreview.innerHTML = `<img src="${data.image_url}" alt="Generated" style="width:100%;height:100%;object-fit:cover">`;

                        await this.renderSlide(this.currentSlide);
                        this.renderSlidesList();
                    } else {
                        this.renderSlidesList(); // just update list thumbnail
                    }

                    if (showSuccessToast) toastr.success('Image generated and applied!');
                    console.log(` Image generated for slide ${slideIndex + 1}`);
                    return true;
                } else {
                    console.error(`Failed to generate image for slide ${slideIndex + 1}:`, data.error);
                    if (showSuccessToast) toastr.error(data.error || 'Failed to generate image');
                    return false;
                }
            } catch (error) {
                console.error(`Error generating image for slide ${slideIndex + 1}:`, error);
                if (showSuccessToast) toastr.error('Failed to generate image');
                return false;
            }
        }


        async init() {
            this.showLoading();

            try {
                // Load slides from backend
                await this.loadSlidesFromBackend();

                if (this.slides.length > 0) {
                    // Initialize Konva
                    await this.initKonva();

                    // Setup event listeners
                    this.setupEventListeners();

                    // Render first slide
                    this.renderSlide(0);
                    this.renderSlidesList();

                    console.log(' Editor initialized with', this.slides.length, 'slides');
                } else {
                    this.showEmptyState();
                    console.warn('No slides found for project', this.projectId);
                }
            } catch (error) {
                console.error('Editor initialization error:', error);
                toastr.error('Failed to initialize editor: ' + error.message);
            } finally {
                this.hideLoading();
            }
        }

        showLoading() {
            document.getElementById('editorLoading').style.display = 'flex';
        }

        hideLoading() {
            document.getElementById('editorLoading').style.display = 'none';
        }

        showEmptyState() {
            document.getElementById('emptyState').style.display = 'flex';
            document.getElementById('currentSlide').textContent = 'No slides available';
        }

        hideEmptyState() {
            document.getElementById('emptyState').style.display = 'none';
        }

        async loadSlidesFromBackend() {
            try {
                console.log('Loading slides for project:', this.projectId);
                const response = await fetch(`/api/project/${this.projectId}/slides/`);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('API Response:', data);

                if (data.success && data.slides && Array.isArray(data.slides)) {
                    this.slides = data.slides.map(slide => {
                        // Parse text_styles if string
                        if (slide.text_styles && typeof slide.text_styles === 'string') {
                            try {
                                slide.text_styles = JSON.parse(slide.text_styles);
                            } catch (e) {
                                slide.text_styles = {};
                            }
                        } else if (!slide.text_styles) {
                            slide.text_styles = {};
                        }

                        // Parse extra_texts if string
                        if (slide.extra_texts && typeof slide.extra_texts === 'string') {
                            try {
                                slide.extra_texts = JSON.parse(slide.extra_texts);
                            } catch (e) {
                                slide.extra_texts = [];
                            }
                        } else if (!slide.extra_texts) {
                            slide.extra_texts = [];
                        }

                        // Parse user_images if string
                        if (slide.user_images && typeof slide.user_images === 'string') {
                            try {
                                slide.user_images = JSON.parse(slide.user_images);
                            } catch (e) {
                                slide.user_images = [];
                            }
                        } else if (!slide.user_images) {
                            slide.user_images = [];
                        }

                        return slide;
                    });
                    this.project = data.project; // Store project data
                    document.getElementById('totalSlides').textContent = this.slides.length;

                    // Log each slide for debugging
                    this.slides.forEach((slide, index) => {
                        console.log(`Slide ${index + 1}:`, {
                            id: slide.id,
                            title: slide.title,
                            hasImage: !!slide.generated_image,
                            bgColor: slide.background_color,
                            fontColor: slide.font_color
                        });
                    });
                } else {
                    throw new Error(data.error || 'Invalid response format');
                }
            } catch (error) {
                console.error('Error loading slides:', error);
                toastr.error('Failed to load slides: ' + error.message);
                throw error;
            }
        }

        async deleteSlide(index) {
            const slide = this.slides[index];
            if (!slide) return;

            console.log('Delete requested for slide:', slide.id, index);

            if (this.slides.length <= 1) {
                toastr.error('Cannot delete the last slide');
                return;
            }

            if (!confirm('Are you sure you want to delete this slide?')) {
                return;
            }

            // Save pending changes
            if (this.autoSaveTimeout) {
                clearTimeout(this.autoSaveTimeout);
                await this.saveCurrentSlideContent();
            }

            try {
                const response = await fetch('/api/delete-slide/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify({ slide_id: slide.id })
                });

                const data = await response.json();

                if (data.success) {
                    // Remove from array
                    this.slides.splice(index, 1);

                    // Adjust current index
                    if (this.currentSlide >= this.slides.length) {
                        this.currentSlide = Math.max(0, this.slides.length - 1);
                    } else if (this.currentSlide > index) {
                        this.currentSlide--;
                    }

                    // Update UI counters
                    // Update UI counters
                    const totalSlidesEl = document.getElementById('totalSlides');
                    if (totalSlidesEl) totalSlidesEl.textContent = this.slides.length;

                    const currentSlideEl = document.getElementById('currentSlide');
                    if (currentSlideEl) currentSlideEl.textContent = `Slide ${this.currentSlide + 1} of ${this.slides.length}`;

                    // Re-render slides list
                    this.renderSlidesList();

                    // Re-render current slide
                    if (this.slides.length > 0) {
                        await this.renderSlide(this.currentSlide);
                        this.updateUIControls(this.slides[this.currentSlide], this.currentSlide);
                    } else {
                        this.showEmptyState();
                    }

                    toastr.success('Slide deleted successfully');
                } else {
                    toastr.error(data.error || 'Failed to delete slide');
                }
            } catch (error) {
                console.error('Error deleting slide:', error);
                toastr.error('Failed to delete slide');
            }
        }

        renderSlidesList() {
            console.log(' renderSlidesList called. Total slides:', this.slides.length);
            const slidesList = document.getElementById('slidesList');
            slidesList.innerHTML = '';

            const editor = this; // Store reference to editor instance

            this.slides.forEach((slide, index) => {
                console.log(' Creating slide item for index:', index, 'Slide:', slide);
                const slideItem = document.createElement('div');
                slideItem.className = `slide-item ${index === this.currentSlide ? 'active' : ''}`;
                slideItem.dataset.index = index;

                // Create background style
                let backgroundStyle = `background-color: ${slide.background_color || '#FFFFFF'};`;

                // If slide has generated image, use it as background
                if (slide.generated_image) {
                    const imageUrl = `/media/${slide.generated_image}`;
                    backgroundStyle = `background-image: url('${imageUrl}'); background-size: cover; background-position: center;`;
                }

                slideItem.innerHTML = `
                <div class="slide-item-header">
                    <div class="slide-item-title" title="${slide.title || 'Slide ' + (index + 1)}">
                        ${slide.title ? slide.title.substring(0, 20) : 'Slide ' + (index + 1)}
                        ${slide.title && slide.title.length > 20 ? '...' : ''}
                    </div>
                    <div class="slide-item-actions">
                        <button class="delete-slide-btn" data-slide-id="${slide.id}" title="Delete slide">
                            <i class="fas fa-trash"></i>
                        </button>
                        <span class="slide-number">${index + 1}</span>
                    </div>
                </div>
                <div class="slide-item-preview" style="${backgroundStyle}; color: ${slide.font_color || '#000000'};">
                    ${slide.generated_image ? '<i class="fas fa-image"></i>' : ''}
                    ${!slide.generated_image && slide.title ? slide.title.substring(0, 15) : 'Preview'}
                </div>
            `;

                slideItem.addEventListener('click', async () => {
                    console.log('Clicked slide:', index, editor.slides[index]);

                    // Save any pending changes to current slide before switching
                    if (editor.autoSaveTimeout) {
                        clearTimeout(editor.autoSaveTimeout);
                        await editor.saveCurrentSlideContent();
                    }

                    // Update current slide index
                    const previousSlide = editor.currentSlide;
                    editor.currentSlide = index;

                    // Update visual selection
                    editor.updateSlidesList();

                    // Render the selected slide
                    await editor.renderSlide(index);

                    // Update edit panel with the selected slide's data
                    const currentSlideData = editor.slides[index];
                    if (currentSlideData) {
                        editor.updateUIControls(currentSlideData, index);

                        // Force update after a short delay to ensure DOM is ready
                        setTimeout(() => {
                            editor.updateUIControls(currentSlideData, index);
                        }, 50);
                    }

                    console.log('Switched to slide:', index, 'Previous:', previousSlide);
                });

                // Add delete button event listener
                const deleteBtn = slideItem.querySelector('.delete-slide-btn');
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent triggering slide selection
                    editor.deleteSlide(index);
                });

                slidesList.appendChild(slideItem);
            });
        }

        updateSlidesList() {
            document.querySelectorAll('.slide-item').forEach((item, index) => {
                item.classList.toggle('active', index === this.currentSlide);
            });
        }

        async saveCurrentSlideContent() {
            if (!this.slides[this.currentSlide]) {
                console.warn('No current slide to save');
                return;
            }

            const slide = this.slides[this.currentSlide];

            // 1. Gather Text Content from DOM (source of truth for text currently being edited)
            const textData = {
                title: document.getElementById('slideTitle')?.value || slide.title || '',
                description: document.getElementById('slideDescription')?.value || slide.description || '',
                image_prompt: document.getElementById('slideImagePrompt')?.value || slide.image_prompt || ''
            };

            // 2. Identify current node positions from Konva Layer if possible
            // (The dragend listener updates local slide state, but let's be sure)
            if (this.layer) {
                const titleNode = this.layer.findOne('.title');
                if (titleNode) {
                    slide.title_x = Math.round(titleNode.x());
                    slide.title_y = Math.round(titleNode.y());
                }
                const descNode = this.layer.findOne('.description');
                if (descNode) {
                    slide.description_x = Math.round(descNode.x());
                    slide.description_y = Math.round(descNode.y());
                }

                // CAPTURE IMAGE TRANSFORMATION
                const imgNode = this.layer.findOne('.generated_image');
                if (imgNode) {
                    if (!slide.text_styles) slide.text_styles = {};
                    slide.text_styles.generated_image = {
                        x: Math.round(imgNode.x()),
                        y: Math.round(imgNode.y()),
                        scaleX: imgNode.scaleX(),
                        scaleY: imgNode.scaleY(),
                        rotation: imgNode.rotation(),
                        width: imgNode.width(),
                        height: imgNode.height()
                    };
                    console.log(' Captured image transformation:', slide.text_styles.generated_image);
                }

                // For dynamically added extra_texts, their positions are updated in addDragSnapping
            }

            // 3. Update local slide object with text data
            Object.assign(slide, textData);

            // 4. Construct Full Payload (Text + Styles + Position)
            // We assume 'slide' object has been updated by other listeners (TextControls, ColorPickers)
            const fullSlideData = {
                title: slide.title,
                description: slide.description,
                image_prompt: slide.image_prompt,
                layout_vibe: slide.layout_vibe || 'corporate',
                extra_text: '', // CRITICAL: Explicitly clear legacy field to prevent re-migration loops in renderSlide

                // Styles
                background_color: slide.background_color,
                font_color: slide.font_color,
                text_styles: slide.text_styles, // Send granular styles
                extra_texts: slide.extra_texts, // Send list
                user_images: slide.user_images, // Send user images

                // saystorys
                saystorys_width: slide.saystorys_width,
                saystorys_height: slide.saystorys_height,

                // Positions
                title_x: slide.title_x,
                title_y: slide.title_y,
                description_x: slide.description_x,
                description_y: slide.description_y,
            };

            // Update slides list display to reflect title changes
            const slideItem = document.querySelector(`.slide-item[data-index="${this.currentSlide}"]`);
            if (slideItem) {
                const titleEl = slideItem.querySelector('.slide-item-title');
                if (titleEl) titleEl.textContent = slide.title || `Slide ${this.currentSlide + 1}`;
            }

            try {
                const response = await fetch('/api/update-slide/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken()
                    },
                    body: JSON.stringify({
                        slide_id: slide.id,
                        slide_data: fullSlideData
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Update local slide with server response to sync IDs/urls etc
                    // But be careful not to overwrite user's active cursor/focus if we re-render?
                    // We just update data, don't re-render entire slide unless necessary.
                    Object.assign(slide, data.slide);
                    // Ensure text_styles is parsed if it comes back as a string
                    if (typeof slide.text_styles === 'string') {
                        slide.text_styles = JSON.parse(slide.text_styles);
                    }
                    if (typeof slide.extra_texts === 'string') {
                        slide.extra_texts = JSON.parse(slide.extra_texts);
                    }
                    console.log('Slide auto-saved successfully');
                } else {
                    console.error('Failed to auto-save slide content:', data.error);
                }
            } catch (error) {
                console.error('Error auto-saving slide content:', error);
            }
        }

        async initKonva() {
            const container = document.getElementById('konvaContainer');

            this.stage = new Konva.Stage({
                container: 'konvaContainer',
                width: 1080,  // Default width
                height: 1080  // Default height
            });

            this.layer = new Konva.Layer();
            this.stage.add(this.layer);

            // Add grid layer
            this.gridLayer = new Konva.Layer();
            this.stage.add(this.gridLayer);
            // this.drawGrid();

            this.hideEmptyState();

            // Add transformer for editing
            this.transformer = new Konva.Transformer({
                rotateEnabled: true,
                borderStroke: '#6366f1',
                borderStrokeWidth: 2,
                anchorStroke: '#6366f1',
                anchorFill: 'white',
                anchorSize: 10
            });
            this.layer.add(this.transformer);



            // Handle window resize - resize stage to fit container
            window.addEventListener('resize', () => {
                this.fitStageToContainer();
            });
        }

        fitStageToContainer() {
            const container = document.querySelector('.saystorys-container');
            if (!container) return;

            const containerWidth = container.clientWidth - 40; // padding/margin buffer
            const containerHeight = container.clientHeight - 40; // padding/margin buffer

            // Get slide dimensions
            const slide = this.slides[this.currentSlide] || { saystorys_width: 1080, saystorys_height: 1080 };
            const sceneWidth = slide.saystorys_width || 1080;
            const sceneHeight = slide.saystorys_height || 1080;

            // Calculate scale to fit
            const scale = Math.min(
                containerWidth / sceneWidth,
                containerHeight / sceneHeight
            );

            // Update stage size and scale
            this.stage.width(sceneWidth * scale);
            this.stage.height(sceneHeight * scale);
            this.stage.scale({ x: scale, y: scale });

            // Redraw
            this.layer.batchDraw();
        }

        async renderSlide(slideIndex) {
            console.log(' renderSlide called with index:', slideIndex);

            if (slideIndex < 0 || slideIndex >= this.slides.length) return;
            const slide = this.slides[slideIndex];

            // Parse JSON fields
            const safeParse = (val, def) => {
                if (!val || typeof val !== 'string') return val || def;
                try { return JSON.parse(val); } catch (e) { return def; }
            };
            if (typeof slide.text_styles === 'string') slide.text_styles = safeParse(slide.text_styles, {});
            if (typeof slide.extra_texts === 'string') slide.extra_texts = safeParse(slide.extra_texts, []);
            if (typeof slide.user_images === 'string') slide.user_images = safeParse(slide.user_images, []);

            const width = slide.saystorys_width || 1080;
            const height = slide.saystorys_height || 1080;
            const vibe = slide.layout_vibe || 'corporate';

            console.log(` Rendering 9-Master Layout: Vibe=${vibe}`);

            this.layer.destroyChildren();

            // Transformer
            this.transformer = new Konva.Transformer({
                nodes: [], rotateEnabled: true, borderStroke: '#6366f1', borderStrokeWidth: 2,
                anchorStroke: '#6366f1', anchorFill: 'white', anchorSize: 10, padding: 5
            });
            this.layer.add(this.transformer);

            this.stage.on('click tap', (e) => {
                if (e.target === this.stage) {
                    this.transformer.nodes([]);
                    this.activeTextTarget = null;
                }
            });

            this.fitStageToContainer();
            this.saveState();

            // --- 9-MASTER LAYOUT GEOMETRY ENGINE ---
            // Common Rule: STRICT FOREGROUND IMAGES. NO FULL BLEED.
            // 1. Corporate Pro
            // 2. Minimal Clean
            // 3. Split Screen
            // 4. Card Layout
            // 5. Gradient Flow
            // 6. Geometric Pro
            // 7. Magazine Style
            // 8. Creative Chaos
            // 9. Neon Glow

            let geo = {
                title: { x: 40, y: 50, w: width - 80, align: 'left', fontSize: 60, fontStyle: 'bold', rotation: 0 },
                body: { x: 40, y: 300, w: width - 80, align: 'left', fontSize: 40, rotation: 0 },
                image: { x: 0, y: 0, w: 0, h: 0, visible: false, fit: 'contain', rotation: 0 },
                card: { x: 0, y: 0, w: 0, h: 0, visible: false },
                bg: { type: 'solid', fill: slide.background_color || '#FFFFFF', gradient: null },
                separators: [],
                shapes: [],
                icons: []
            };

            const hasImage = !!slide.generated_image;
            let bgColor = slide.background_color || '#FFFFFF';
            let textColor = slide.font_color || '#000000';

            // --- VIBE LOGIC ---

            if (vibe === 'corporate') {
                // 1. CORPORATE PRO (Polished)
                // Headline top, Image Right/Below. Dividers. Professional feel.
                geo.title.y = 80;
                geo.title.align = 'center';
                geo.title.fontFamily = 'Montserrat'; // Premium font
                geo.title.fontStyle = '800'; // Extra Bold

                if (hasImage) {
                    const imgW = width * 0.45;
                    const contentW = width - imgW - 140;
                    geo.image = {
                        x: width - imgW - 60,
                        y: 160,
                        w: imgW,
                        h: height * 0.65,
                        visible: true,
                        fit: 'cover',
                        cornerRadius: 8,
                        shadowColor: 'black',
                        shadowBlur: 20,
                        shadowOpacity: 0.15
                    };
                    geo.title.align = 'left'; geo.title.x = 60; geo.title.w = contentW;
                    geo.body = { x: 60, y: 240, w: contentW, align: 'left', fontFamily: 'Open Sans' };
                    geo.separators.push({ points: [60, 200, width * 0.4, 200], strokeWidth: 3 }); // Thicker accent
                } else {
                    geo.title.align = 'center'; geo.title.x = width * 0.1; geo.title.w = width * 0.8;
                    geo.body.align = 'center'; geo.body.x = width * 0.15; geo.body.w = width * 0.7; geo.body.y = 280;
                    geo.separators.push({ points: [width * 0.35, 220, width * 0.65, 220], strokeWidth: 2 });
                }
            }
            else if (vibe === 'minimal') {
                // 2. MINIMAL CLEAN (Polished)
                // Centered, Whitespace. No dividers. Pure.
                geo.bg.fill = bgColor === '#FFFFFF' ? '#fafafa' : bgColor;
                geo.title.align = 'center';
                geo.title.fontSize = 55;
                geo.title.fontStyle = 'normal';
                geo.title.fontFamily = 'Inter'; // Clean sans
                geo.title.y = height * 0.15;

                let contentY = height * 0.3;
                if (hasImage) {
                    const imgH = height * 0.35;
                    const imgW = width * 0.6;
                    geo.image = { x: (width - imgW) / 2, y: contentY, w: imgW, h: imgH, visible: true, fit: 'contain' };
                    contentY += imgH + 60;
                }
                geo.body.align = 'center'; geo.body.fontSize = 35;
                geo.body.x = width * 0.2; geo.body.w = width * 0.6; geo.body.y = contentY;
            }
            else if (vibe === 'split') {
                // 3. SPLIT SCREEN (STRICT)
                // Left: Image Only. Right: Text Only.
                const half = width / 2;
                geo.bg.type = 'split';

                // Image Left
                geo.image = { x: 40, y: 40, w: half - 80, h: height - 80, visible: true, fit: 'contain' };
                // If no image, maybe a placeholder icon or color? strict rules say "image or visual only"

                // Text Right
                geo.title = { x: half + 60, y: 100, w: half - 120, align: 'left', fontSize: 55 };
                geo.body = { x: half + 60, y: 300, w: half - 120, align: 'left' };

                // Divider
                geo.separators.push({ points: [half, 40, half, height - 40], vertical: true, strokeWidth: 2 });
            }
            else if (vibe === 'card') {
                // 4. CARD LAYOUT (REFINED - ROUNDED & CLEAN)
                // Reference: Clean centered card, heavy rounded corners, soft shadow.

                geo.bg.type = 'card';
                geo.bg.fill = bgColor; // Use user-selected background (can be dark/colored)

                // Enforce Dark Text for White Card
                // Since card body is always white, we must ensure text is visible.
                if (textColor.toLowerCase() === '#ffffff' || textColor.toLowerCase() === '#fff') {
                    textColor = '#000000';
                }

                const cardMargin = 80; // More breather room from edge
                const cardW = width - (cardMargin * 2);
                const cardH = height - (cardMargin * 2);
                const innerPad = 70; // Airy internal padding
                const contentW = cardW - (innerPad * 2);

                // --- ROUNDED CARD GEOMETRY ---
                geo.card = {
                    x: cardMargin,
                    y: cardMargin,
                    w: cardW,
                    h: cardH,
                    visible: true,
                    cornerRadius: 40, // Heavy rounded corners
                    shadowColor: 'black',
                    shadowBlur: 30,
                    shadowOpacity: 0.08, // Soft premium shadow
                    shadowOffset: { x: 0, y: 10 }
                };

                // --- DYNAMIC STACKING LOGIC ---
                // Flow: Title (Top) -> Image (Center) -> Body (Bottom)

                // 1. Measure Title
                const measureTitle = new Konva.Text({
                    text: slide.title || 'Slide Title',
                    width: contentW,
                    fontSize: 55, // Larger title
                    fontFamily: 'Poppins',
                    fontStyle: 'bold',
                    align: 'center',
                    lineHeight: 1.2
                });
                const titleH = measureTitle.height();

                // 2. Measure Body
                const measureDesc = new Konva.Text({
                    text: slide.description || 'Slide content...',
                    width: contentW,
                    fontSize: 32, // Readable body
                    fontFamily: 'Inter',
                    align: 'center',
                    lineHeight: 1.5
                });
                const descH = measureDesc.height();

                // 3. Image Height
                let imgH = 0;
                if (hasImage) {
                    imgH = cardH * 0.35; // ~35% height for image
                }

                // 3.5 Smart Icons
                // Position: Top Right Header of Card (Clean)
                const smartIcons = this.getIconsForText((slide.title || '') + ' ' + (slide.description || ''), 3);
                if (smartIcons.length > 0) {
                    geo.icons = smartIcons.map((icon, i) => ({
                        text: icon,
                        x: cardMargin + cardW - innerPad - 40 - (i * 60),
                        y: cardMargin + 40,
                        w: 50,
                        fontSize: 40,
                        align: 'center'
                    }));
                }

                // 4. Calculate Spacing
                const gap = 50;
                let totalContentH = titleH + descH;
                if (hasImage) totalContentH += imgH + gap;
                totalContentH += gap;

                // 5. Center Vertically
                let startY = cardMargin + innerPad + ((cardH - (innerPad * 2)) - totalContentH) / 2;
                if (startY < cardMargin + innerPad) startY = cardMargin + innerPad;

                let currentY = startY;

                // Title
                geo.title = {
                    x: cardMargin + innerPad,
                    y: currentY,
                    w: contentW,
                    align: 'center',
                    fontSize: 55,
                    fontStyle: 'bold'
                };
                currentY += titleH + gap;

                // Image
                if (hasImage) {
                    geo.image = {
                        x: cardMargin + innerPad,
                        y: currentY,
                        w: contentW,
                        h: imgH,
                        visible: true,
                        fit: 'contain',
                        cornerRadius: 12 // Soft corners on image too
                    };
                    currentY += imgH + gap;
                }

                // Body
                geo.body = {
                    x: cardMargin + innerPad,
                    y: currentY,
                    w: contentW,
                    align: 'center',
                    fontSize: 32
                };
            }


            else if (vibe === 'gradient') {
                // 5. GRADIENT FLOW
                // Horizontal/Diagonal Gradient. Content aligned.
                geo.bg.type = 'gradient';
                geo.bg.gradient = {
                    start: { x: 0, y: 0 }, end: { x: width, y: height }, // Diagonal
                    stops: [0, '#6366f1', 1, '#ec4899'] // Indigo -> Pink
                };
                textColor = '#ffffff';

                geo.title.align = 'left'; geo.title.x = 80; geo.title.y = 120; geo.title.w = width * 0.6;
                geo.body.align = 'left'; geo.body.x = 80; geo.body.y = 350; geo.body.w = width * 0.5;

                if (hasImage) {
                    // Image Bottom Right flowing
                    const imgW = width * 0.4;
                    geo.image = { x: width - imgW - 60, y: height * 0.3, w: imgW, h: height * 0.5, visible: true, fit: 'contain' };
                }
            }
            else if (vibe === 'geometric') {
                // 6. GEOMETRIC PRO (WoW Version)
                // Glassy Grid: Transparent structures that sit ON TOP of user background.
                geo.bg.fill = bgColor; // Respect user choice!

                const gridColor = bgColor === '#FFFFFF' || bgColor === '#ffffff' ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.2)';
                const accentColor = bgColor === '#FFFFFF' || bgColor === '#ffffff' ? '#000000' : '#FFFFFF';

                // 1. Main Content Frame (Floating Glass)
                geo.shapes.push(
                    {
                        type: 'rect', x: 40, y: 40, w: width - 80, h: height - 80,
                        stroke: gridColor, strokeWidth: 2,
                        cornerRadius: 0 // Sharp geometric look
                    },
                    // Corner Accents (The "Tech" feel)
                    { type: 'line', points: [40, 80, 40, 40, 80, 40], stroke: accentColor, strokeWidth: 4 },
                    { type: 'line', points: [width - 80, height - 40, width - 40, height - 40, width - 40, height - 80], stroke: accentColor, strokeWidth: 4 }
                );

                // 2. Title & Body Grid
                // Split top area for title
                geo.shapes.push({
                    type: 'line', points: [40, height * 0.35, width - 40, height * 0.35],
                    stroke: gridColor, strokeWidth: 1
                });

                geo.title.x = 60; geo.title.y = 80; geo.title.w = width - 120;
                geo.title.fontSize = 65;
                geo.title.align = 'left';
                geo.title.fontFamily = 'Montserrat';
                geo.title.fontStyle = 'normal';

                geo.body.x = width * 0.45; geo.body.y = height * 0.4; geo.body.w = width * 0.5;
                geo.body.align = 'left';
                geo.body.fontSize = 32;

                // 3. Image Placement (Geometric Cutout)
                if (hasImage) {
                    // Image takes bottom-left quadrant
                    geo.image = {
                        x: 40, y: height * 0.35,
                        w: width * 0.4,
                        h: height * 0.65 - 40,
                        visible: true,
                        fit: 'cover'
                    };
                    // Vertical divider for image
                    geo.shapes.push({
                        type: 'line', points: [40 + width * 0.4, height * 0.35, 40 + width * 0.4, height - 40],
                        stroke: gridColor, strokeWidth: 1
                    });
                } else {
                    // Full width body if no image
                    geo.body.x = 60; geo.body.w = width - 120;
                }
            }
            else if (vibe === 'magazine') {
                // 7. MAGAZINE STYLE
                // Asymmetric, editorial columns.
                geo.bg.fill = '#ffffff';
                geo.title.fontSize = 100; geo.title.fontStyle = 'bold'; geo.title.align = 'left';
                geo.title.x = 60; geo.title.y = 60; geo.title.w = width - 120;

                const colW = (width - 180) / 2;
                geo.separators.push({ points: [60, 300, width - 60, 300], strokeWidth: 5, stroke: '#000000' }); // Strong header line

                if (hasImage) {
                    // Image Left Col
                    geo.image = { x: 60, y: 340, w: colW, h: height - 400, visible: true, fit: 'cover' };
                    // Text Right Col
                    geo.body = { x: width / 2 + 30, y: 340, w: colW, align: 'left', fontSize: 35 };
                } else {
                    geo.body = { x: 60, y: 340, w: colW, align: 'left' }; // Text Left
                    // Maybe quote right?
                }
            }
            else if (vibe === 'creative') {
                // 8. CREATIVE CHAOS (WoW Version)
                // Editorial Fashion Magazine Style: Massive typography, drastic rotation, dynamic visual tension.

                // Background: Dynamic Abstract
                geo.bg.fill = bgColor === '#FFFFFF' ? '#fff1f2' : bgColor;
                if (bgColor === '#FFFFFF') {
                    // Add a giant abstract shape background if default white
                    geo.shapes.push(
                        { type: 'circle', x: width * 0.9, y: 0, radius: width * 0.5, fill: '#ffecd2' },
                        { type: 'circle', x: 0, y: height, radius: width * 0.4, fill: '#fcb69f' }
                    );
                }

                // 1. MASSIVE Title (Rotated & Bleeding off edge)
                geo.title = {
                    x: 40,
                    y: 120,
                    w: width * 0.8,
                    align: 'left',
                    fontSize: 110, // Huge
                    fontStyle: '900', // Black weight
                    rotation: -8 // Aggressive tilt
                };

                // 2. Image (Overlapping the Title, opposite tilt)
                if (hasImage) {
                    geo.image = {
                        x: width * 0.25,
                        y: 350,
                        w: width * 0.65,
                        h: height * 0.5,
                        visible: true,
                        fit: 'cover',
                        rotation: 3, // Counter-rotation
                        border: { color: 'white', width: 15 }, // Photo frame effect
                        shadowColor: 'black',
                        shadowBlur: 30,
                        shadowOpacity: 0.2
                    };
                }

                // 3. Body (Sticker style / floating)
                geo.body = {
                    x: 40,
                    y: height - 180,
                    w: width * 0.5,
                    align: 'left',
                    fontSize: 32,
                    rotation: 0, // Stabilize reading
                    fontStyle: 'bold'
                };

                // Decorative "Tape" or "Brush" elements
                geo.shapes.push(
                    { type: 'rect', x: width * 0.2, y: 340, w: 200, h: 20, fill: '#ff0055', rotation: 3 }, // Accent strip
                    { type: 'rect', x: width * 0.8, y: height - 100, w: 100, h: 100, stroke: 'black', strokeWidth: 5, rotation: 20 }
                );
            }
            else if (vibe === 'neon') {
                // 9. NEON CYBERPUNK (WoW Version)
                // Dark mode, Glow effects, Futuristic.
                if (bgColor === '#FFFFFF') bgColor = '#050510'; // Deepest dark blue/black
                geo.bg.fill = bgColor;

                // Force white/cyan text base
                textColor = '#e2e8f0';

                // 1. Glowing Title
                geo.title = {
                    x: 50, y: 80, w: width - 100,
                    align: 'center',
                    fontSize: 75,
                    fontFamily: 'Montserrat', // Modern geometric
                    fontStyle: '900',
                    shadowColor: '#00d0ff', // Cyan Glow
                    shadowBlur: 25,
                    shadowOpacity: 1
                };

                // 2. Image with Cyber Border
                let contentY = 300;
                if (hasImage) {
                    const imgH = height * 0.35;
                    const imgW = width * 0.8;
                    geo.image = {
                        x: (width - imgW) / 2,
                        y: 280,
                        w: imgW,
                        h: imgH,
                        visible: true,
                        fit: 'cover',
                        cornerRadius: 4,
                        border: { color: '#d946ef', width: 4 }, // Magenta Border
                        shadowColor: '#d946ef',
                        shadowBlur: 30, // Magenta Glow
                        shadowOpacity: 0.6
                    };
                    contentY = 280 + imgH + 60;
                }

                // 3. Body with tech feel
                geo.body = {
                    x: 60, y: contentY, w: width - 120,
                    align: 'center',
                    fontSize: 34,
                    fontFamily: 'Roboto Mono' // Tech font
                };

                // 4. Cyber Accents (Grid lines / lasers)
                geo.shapes.push(
                    { type: 'line', points: [0, 20, width, 20], stroke: '#00d0ff', strokeWidth: 2, shadowColor: '#00d0ff', shadowBlur: 10 },
                    { type: 'line', points: [0, height - 20, width, height - 20], stroke: '#00d0ff', strokeWidth: 2, shadowColor: '#00d0ff', shadowBlur: 10 }
                );
            }


            // --- GLOBAL SMART ICON FALLBACK ---
            // If the specific layout didn't define icons, we add them by default.
            // If the specific layout didn't define icons, we add them by default.
            // --- GLOBAL SMART ICON FALLBACK ---
            // If the specific layout didn't define icons, we add them by default.
            if (!geo.icons || geo.icons.length === 0) {
                const iconSearchText = (slide.title || '') + ' ' + (slide.description || '');
                console.log(' Smart Icon Fallback Triggered for text:', iconSearchText);

                const smartIcons = this.getIconsForText(iconSearchText, 3);
                console.log(' Found Smart Icons:', smartIcons);

                if (smartIcons.length > 0) {
                    // Default Position: Top Right
                    let iconBaseY = 40;

                    // Specific overrides for layouts that might overlap
                    if (vibe === 'magazine') iconBaseY = 20; // Push higher for magazine

                    geo.icons = smartIcons.map((icon, i) => ({
                        text: icon,
                        x: width - 80 - (i * 60),
                        y: iconBaseY,
                        w: 50,
                        fontSize: 40,
                        align: 'center',
                        shadowColor: 'black',
                        shadowBlur: 5,
                        shadowOpacity: 0.3
                    }));
                    console.log(' Assigned icons to geo object:', geo.icons);

                    // DEBUG: Visual confirmation dot at top-left
                    /* this.layer.add(new Konva.Circle({
                         x: 50, y: 50, radius: 20, fill: 'red', name: 'debug_dot'
                     }));*/
                }
            } else {
                console.log(' Layout already has icons:', geo.icons);
            }

            // --- RENDER EXECUTION ---

            // 1. Background
            if (geo.bg.type === 'split') {
                this.layer.add(new Konva.Rect({ x: 0, y: 0, width: width / 2, height: height, fill: '#f1f5f9', name: 'bg_split_L' }));
                this.layer.add(new Konva.Rect({ x: width / 2, y: 0, width: width / 2, height: height, fill: bgColor, name: 'bg_split_R' }));
            } else if (geo.bg.type === 'card') {
                this.layer.add(new Konva.Rect({ x: 0, y: 0, width: width, height: height, fill: geo.bg.fill, name: 'bg_base' })); // Base
                this.layer.add(new Konva.Rect({
                    x: geo.card.x, y: geo.card.y, width: geo.card.w, height: geo.card.h,
                    fill: '#ffffff',
                    cornerRadius: 24,
                    shadowColor: 'black',
                    shadowBlur: 40,
                    shadowOpacity: 0.15,
                    cornerRadius: 24,
                    shadowColor: 'black',
                    shadowBlur: 40,
                    shadowOpacity: 0.25, // Increased opacity for visibility
                    shadowOffset: { x: 0, y: 15 },
                    stroke: 'rgba(0,0,0,0.05)', // Subtle border to define edge
                    strokeWidth: 1,
                    name: 'bg_card' // Critical for layering
                }));
            } else if (geo.bg.type === 'gradient') {
                const bg = new Konva.Rect({
                    x: 0, y: 0, width: width, height: height,
                    fillLinearGradientStartPoint: geo.bg.gradient.start,
                    fillLinearGradientEndPoint: geo.bg.gradient.end,
                    fillLinearGradientColorStops: geo.bg.gradient.stops,
                    name: 'background_base'
                });
                this.layer.add(bg);
            } else {
                this.layer.add(new Konva.Rect({ x: 0, y: 0, width: width, height: height, fill: bgColor, name: 'background_base' }));
            }

            // 2. Shapes (Geometric / Creative)
            if (geo.shapes && geo.shapes.length > 0) {
                geo.shapes.forEach(shape => {
                    let node;
                    if (shape.type === 'rect') node = new Konva.Rect(shape);
                    else if (shape.type === 'line') node = new Konva.Line(shape);
                    else if (shape.type === 'circle') node = new Konva.Circle(shape);
                    if (node) { node.name('geo_shape'); this.layer.add(node); }
                });
            }

            // 2.5 Smart Icons (Render BEFORE image to ensure they appear even if image hangs)
            if (geo.icons && geo.icons.length > 0) {
                geo.icons.forEach((icon, i) => {
                    const iconNode = new Konva.Text({
                        x: icon.x,
                        y: icon.y,
                        width: icon.w,
                        text: icon.text,
                        fontSize: icon.fontSize,
                        fontFamily: 'Segoe UI Emoji, Apple Color Emoji, sans-serif',
                        fill: textColor, // Use calculated theme color
                        align: icon.align,
                        name: 'smart_icon',
                        draggable: true
                    });
                    // Add subtle shadow for depth
                    iconNode.shadowColor('black');
                    iconNode.shadowBlur(5);
                    iconNode.shadowOpacity(0.2);

                    this.layer.add(iconNode);
                });
            }

            // 3. Image
            if (hasImage && geo.image.visible) {
                const imgUrl = `/media/${slide.generated_image}`;
                const loadImage = () => new Promise(resolve => {
                    Konva.Image.fromURL(imgUrl, (imgNode) => {
                        const imgW = imgNode.width();
                        const imgH = imgNode.height();
                        const containerW = geo.image.w;
                        const containerH = geo.image.h;

                        // Fitting
                        let scale = 1;
                        const ratioX = containerW / imgW;
                        const ratioY = containerH / imgH;

                        if (geo.image.fit === 'cover') scale = Math.max(ratioX, ratioY);
                        else scale = Math.min(ratioX, ratioY);

                        const finalW = imgW * scale;
                        const finalH = imgH * scale;
                        const finalX = geo.image.x + (containerW - finalW) / 2;
                        const finalY = geo.image.y + (containerH - finalH) / 2;

                        imgNode.setAttrs({
                            x: finalX, y: finalY, width: finalW, height: finalH,
                            rotation: geo.image.rotation || 0,
                            cornerRadius: geo.image.cornerRadius || 0,
                            shadowColor: geo.image.shadowColor || null,
                            shadowBlur: geo.image.shadowBlur || 0,
                            shadowOpacity: geo.image.shadowOpacity || 0,
                            stroke: geo.image.border ? geo.image.border.color : null,
                            strokeWidth: geo.image.border ? geo.image.border.width : 0,
                            name: 'generated_image', draggable: true
                        });

                        if (geo.image.fit === 'cover') {
                            imgNode.crop({
                                x: (imgW - containerW / scale) / 2,
                                y: (imgH - containerH / scale) / 2,
                                width: containerW / scale,
                                height: containerH / scale
                            });
                            imgNode.width(containerW); imgNode.height(containerH);
                            imgNode.x(geo.image.x); imgNode.y(geo.image.y);
                            imgNode.scale({ x: 1, y: 1 });
                        }

                        imgNode.on('transformend dragend', () => this.debouncedSave());
                        imgNode.on('click tap', () => { this.transformer.nodes([imgNode]); });
                        imgNode.on('mouseenter', () => this.stage.container().style.cursor = 'move');
                        imgNode.on('mouseleave', () => this.stage.container().style.cursor = 'default');
                        this.layer.add(imgNode);
                        resolve(imgNode);
                    });

                    // Error handling for 404s or broken links
                    const imgTest = new Image();
                    imgTest.src = imgUrl;
                    imgTest.onerror = () => {
                        console.error(' Failed to load image:', imgUrl);
                        resolve(null); // Resolve anyway to continue rendering rest of slide
                    };
                });
                await loadImage();
            }



            // 4. Text
            const title = new Konva.Text({
                x: geo.title.x, y: geo.title.y, width: geo.title.w,
                text: slide.title || 'Slide Title',
                fontSize: geo.title.fontSize || 60,
                fontStyle: geo.title.fontStyle || 'bold',
                fontFamily: geo.title.fontFamily || 'Poppins',
                fill: textColor,
                align: geo.title.align,
                rotation: geo.title.rotation || 0,
                shadowColor: geo.title.shadowColor || null,
                shadowBlur: geo.title.shadowBlur || 0,
                shadowOpacity: geo.title.shadowOpacity || 0,
                name: 'title', draggable: true
            });

            const body = new Konva.Text({
                x: geo.body.x, y: geo.body.y, width: geo.body.w,
                text: slide.description || 'Slide content...',
                fontSize: geo.body.fontSize || 40,
                fontFamily: geo.body.fontFamily || 'Inter',
                fill: textColor,
                align: geo.body.align,
                rotation: geo.body.rotation || 0,
                shadowColor: geo.body.shadowColor || null,
                shadowBlur: geo.body.shadowBlur || 0,
                shadowOpacity: geo.body.shadowOpacity || 0,
                name: 'description', draggable: true, lineHeight: 1.4
            });

            // (Removed hardcoded neon check - now handled by geo properties)

            // Text Overrides
            if (slide.text_styles) {
                const apply = (node, name) => {
                    const ts = slide.text_styles[name];
                    if (ts) {
                        if (ts.fill) node.fill(ts.fill);
                        if (ts.fontFamily) node.fontFamily(ts.fontFamily);
                        if (ts.fontStyle) node.fontStyle(ts.fontStyle);
                        if (ts.textDecoration) node.textDecoration(ts.textDecoration);
                        if (ts.fontSize) node.fontSize(ts.fontSize);
                    }
                };
                apply(title, 'title');
                apply(body, 'description');
            }
            this.layer.add(title, body);

            // 5. Separators
            if (geo.separators.length > 0) {
                geo.separators.forEach(sep => {
                    const line = new Konva.Line({
                        points: sep.points, stroke: sep.stroke || textColor, strokeWidth: sep.strokeWidth || 1, opacity: 0.5,
                        name: 'separator_auto'
                    });
                    this.layer.add(line);
                });
            }

            // 6. User Stuff
            if (slide.extra_texts) slide.extra_texts.forEach(item => this.renderExtraTextItem(item));
            if (slide.user_images) slide.user_images.forEach(img => this.renderUserImage(img));

            // Finalize
            this.addDragSnapping(title);
            this.addDragSnapping(body);
            this.makeEditable(title, 'title');
            this.makeEditable(body, 'description');

            this.updateUIControls(slide, slideIndex);

            // Layering
            // Layering - FINAL PASS
            // Layering - FINAL PASS
            const bgBase = this.layer.findOne('.background_base') || this.layer.findOne('.bg_base');
            if (bgBase) bgBase.moveToBottom();

            const bgCard = this.layer.findOne('.bg_card');
            if (bgCard) {
                bgCard.zIndex(1); // Ensure card is just above base
            }

            // Force icons to very top (Debug fix)
            const icons = this.layer.find('.smart_icon');
            icons.forEach(icon => {
                console.log('Icon Render:', { x: icon.x(), y: icon.y(), text: icon.text(), fill: icon.fill() });
                icon.moveToTop();
            });

            this.layer.batchDraw();
            console.log(' 9-Master Layout Rendered (Strict)');
        }


        applyStoredStyles() {
            const slide = this.slides[this.currentSlide];
            if (!slide || !slide.text_styles) return;

            const styles = slide.text_styles;
            const nodes = ['title', 'description']; // Removed 'extraText'

            nodes.forEach(name => {
                const nodeStyles = styles[name];
                if (nodeStyles) {
                    const node = this.layer.findOne('.' + name); // class selector if name used as class? or check name
                    // Konva findOne('.name') works for name property
                    if (node) {
                        // Apply known style properties
                        if (nodeStyles.fill) node.fill(nodeStyles.fill);
                        if (nodeStyles.fontSize) node.fontSize(nodeStyles.fontSize);
                        if (nodeStyles.fontFamily) node.fontFamily(nodeStyles.fontFamily);
                        if (nodeStyles.fontStyle) node.fontStyle(nodeStyles.fontStyle);
                        if (nodeStyles.align) node.align(nodeStyles.align);
                        if (nodeStyles.lineHeight) node.lineHeight(nodeStyles.lineHeight);
                        if (nodeStyles.letterSpacing) node.letterSpacing(nodeStyles.letterSpacing);
                        if (nodeStyles.textTransform) {
                            // Text transform is tricky as it modifies content, rely on stored content?
                            // Actually we should store transform state if we want to reverse it
                            // For now, apply it directly to the text content
                            const originalText = node.text();
                            switch (nodeStyles.textTransform) {
                                case 'uppercase': node.text(originalText.toUpperCase()); break;
                                case 'lowercase': node.text(originalText.toLowerCase()); break;
                                case 'capitalize': node.text(originalText.replace(/\b\w/g, l => l.toUpperCase())); break;
                            }
                        }
                    }
                }
            });
            this.layer.batchDraw();
        }

        async loadImageAsBackground(imageUrl, width, height) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';

                img.onload = () => {
                    const bgImage = new Konva.Image({
                        x: 0,
                        y: 0,
                        image: img,
                        width: width,
                        height: height,
                        name: 'backgroundImage'
                    });

                    this.layer.add(bgImage);
                    bgImage.moveToBottom();
                    resolve();
                };

                img.onerror = (error) => {
                    console.error('Failed to load image:', imageUrl, error);
                    // Fallback to color background
                    const background = new Konva.Rect({
                        x: 0,
                        y: 0,
                        width: width,
                        height: height,
                        fill: this.slides[this.currentSlide].background_color || '#FFFFFF',
                        stroke: '#e5e7eb',
                        strokeWidth: 1,
                        name: 'background'
                    });
                    this.layer.add(background);
                    reject(error);
                };

                img.src = imageUrl;
            });
        }

        updateUIControls(slide, slideIndex) {
            if (!slide) {
                console.warn('updateUIControls called with null/undefined slide');
                return;
            }

            console.log('Updating UI controls for slide:', slideIndex, slide);

            try {
                // Update slide counter
                const currentSlideNumberEl = document.getElementById('currentSlideNumber');
                const currentSlideEl = document.getElementById('currentSlide');

                if (currentSlideNumberEl) {
                    currentSlideNumberEl.textContent = slideIndex + 1;
                }
                if (currentSlideEl) {
                    currentSlideEl.textContent = `Slide ${slideIndex + 1} of ${this.slides.length}`;
                }

                // Update form fields with null checks
                const fields = [
                    { id: 'slideTitle', value: slide.title || '' },
                    { id: 'slideDescription', value: slide.description || '' },
                    { id: 'slideImagePrompt', value: slide.image_prompt || '' },
                    { id: 'imagePrompt', value: slide.image_prompt || '' }, // Also populate the generate field
                    { id: 'bgColor', value: slide.background_color || '#FFFFFF' },
                    { id: 'fontColor', value: slide.font_color || '#000000' },
                    { id: 'saystorysWidth', value: slide.saystorys_width || 1080 },
                    { id: 'saystorysHeight', value: slide.saystorys_height || 1080 }
                ];

                fields.forEach(field => {
                    const element = document.getElementById(field.id);
                    if (element) {
                        element.value = field.value;
                    } else {
                        console.warn(`Element with id '${field.id}' not found`);
                    }
                });

                // Update text style controls based on current slide's text_styles
                const updateControl = (elementId, value, type = 'value') => {
                    const element = document.getElementById(elementId);
                    if (element) {
                        if (type === 'value') element.value = value;
                        else if (type === 'activeClass') {
                            // For button groups, remove active from all siblings and add to the one matching value
                            const siblings = element.parentElement.querySelectorAll(`.${element.className.split(' ')[0]}`);
                            siblings.forEach(sib => sib.classList.remove('active'));
                            const targetButton = Array.from(siblings).find(btn => btn.getAttribute(element.dataset.attr) === value);
                            if (targetButton) targetButton.classList.add('active');
                        }
                    }
                };

                const currentStyles = slide.text_styles || {};

                // Title controls
                const titleStyles = currentStyles.title || {};
                updateControl('titleColor', titleStyles.fill || slide.font_color || '#000000');
                updateControl('titleFontSize', titleStyles.fontSize || 48);
                updateControl('titleFontFamily', titleStyles.fontFamily || 'Poppins');

                // Weight (Bold)
                const isTitleBold = titleStyles.fontStyle && titleStyles.fontStyle.includes('bold');
                const titleBoldBtn = document.querySelector('.title-weight-btn[data-weight="bold"]');
                if (titleBoldBtn) {
                    if (isTitleBold) titleBoldBtn.classList.add('active');
                    else titleBoldBtn.classList.remove('active');
                }

                // Style (Italic)
                const isTitleItalic = titleStyles.fontStyle && titleStyles.fontStyle.includes('italic');
                const titleItalicBtn = document.querySelector('.title-style-btn[data-style="italic"]');
                if (titleItalicBtn) {
                    if (isTitleItalic) titleItalicBtn.classList.add('active');
                    else titleItalicBtn.classList.remove('active');
                }

                // Decoration (Underline)
                const isTitleUnderline = titleStyles.textDecoration && titleStyles.textDecoration.includes('underline');
                const titleUnderlineBtn = document.querySelector('.title-decoration-btn[data-decoration="underline"]');
                if (titleUnderlineBtn) {
                    if (isTitleUnderline) titleUnderlineBtn.classList.add('active');
                    else titleUnderlineBtn.classList.remove('active');
                }

                const titleAlignBtn = document.querySelector(`.title-alignment-btn[data-align="${titleStyles.align || 'center'}"]`);
                if (titleAlignBtn) {
                    document.querySelectorAll('.title-alignment-btn').forEach(btn => btn.classList.remove('active'));
                    titleAlignBtn.classList.add('active');
                }

                // Layout Vibe Controls
                const currentVibe = slide.layout_vibe || 'corporate';
                document.querySelectorAll('.layout-vibe-btn').forEach(btn => btn.classList.remove('active'));
                const activeVibeBtn = document.querySelector(`.layout-vibe-btn[data-vibe="${currentVibe}"]`);
                if (activeVibeBtn) activeVibeBtn.classList.add('active');


                // Description controls
                const descriptionStyles = currentStyles.description || {};
                updateControl('descriptionColor', descriptionStyles.fill || slide.font_color || '#000000');
                updateControl('descriptionFontSize', descriptionStyles.fontSize || 24);
                updateControl('descriptionFontFamily', descriptionStyles.fontFamily || 'Inter');

                // Weight (Bold)
                const isDescBold = descriptionStyles.fontStyle && descriptionStyles.fontStyle.includes('bold');
                const descBoldBtn = document.querySelector('.description-weight-btn[data-weight="bold"]');
                if (descBoldBtn) {
                    if (isDescBold) descBoldBtn.classList.add('active');
                    else descBoldBtn.classList.remove('active');
                }

                // Style (Italic)
                const isDescItalic = descriptionStyles.fontStyle && descriptionStyles.fontStyle.includes('italic');
                const descItalicBtn = document.querySelector('.description-style-btn[data-style="italic"]');
                if (descItalicBtn) {
                    if (isDescItalic) descItalicBtn.classList.add('active');
                    else descItalicBtn.classList.remove('active');
                }

                // Decoration (Underline)
                const isDescUnderline = descriptionStyles.textDecoration && descriptionStyles.textDecoration.includes('underline');
                const descUnderlineBtn = document.querySelector('.description-decoration-btn[data-decoration="underline"]');
                if (descUnderlineBtn) {
                    if (isDescUnderline) descUnderlineBtn.classList.add('active');
                    else descUnderlineBtn.classList.remove('active');
                }

                const descriptionAlignBtn = document.querySelector(`.description-alignment-btn[data-align="${descriptionStyles.align || 'center'}"]`);
                if (descriptionAlignBtn) {
                    document.querySelectorAll('.description-alignment-btn').forEach(btn => btn.classList.remove('active'));
                    descriptionAlignBtn.classList.add('active');
                }

                // General text controls (assuming these apply to all text nodes, and we store them under 'all' or apply to each)
                // For now, let's assume these are applied to 'title' and 'description' for UI display
                updateControl('lineHeight', titleStyles.lineHeight || 1.2); // Default for title
                updateControl('letterSpacing', titleStyles.letterSpacing || 0); // Default for title
                const transformBtn = document.querySelector(`.transform-btn[data-transform="${titleStyles.textTransform || 'none'}"]`);
                if (transformBtn) {
                    document.querySelectorAll('.transform-btn').forEach(btn => btn.classList.remove('active'));
                    transformBtn.classList.add('active');
                }


                console.log('Form fields updated:', {
                    title: slide.title,
                    description: slide.description,
                    imagePrompt: slide.image_prompt
                });

                // Update generated image URL and preview if exists
                const generatedImageUrlEl = document.getElementById('generatedImageUrl');
                const imagePreviewEl = document.getElementById('imagePreview');

                if (slide.generated_image) {
                    const imageUrl = `/media/${slide.generated_image}`;

                    if (generatedImageUrlEl) {
                        generatedImageUrlEl.value = imageUrl;
                    }

                    // Update image preview
                    if (imagePreviewEl) {
                        imagePreviewEl.innerHTML = `<img src="${imageUrl}" alt="Generated" style="width:100%;height:100%;object-fit:cover">`;
                    }
                } else {
                    if (generatedImageUrlEl) {
                        generatedImageUrlEl.value = '';
                    }

                    if (imagePreviewEl) {
                        imagePreviewEl.innerHTML = `
                        <div class="empty-preview">
                            <i class="fas fa-image"></i>
                            <p>No image generated yet</p>
                        </div>
                    `;
                    }
                }

            } catch (error) {
                console.error('Error in updateUIControls:', error);
            }
        }

        makeEditable(textNode, fieldName) {
            // Keep existing logic but use EditTextNode if generalized
            // For now standard nodes use input fields, extra texts use double click saystorys edit
            textNode.on('dblclick dbltap', () => {
                // If it's a standard node, maybe focus the sidebar input?
                const inputId = fieldName === 'title' ? 'slideTitle' : (fieldName === 'description' ? 'slideDescription' : null);
                if (inputId) {
                    const input = document.getElementById(inputId);
                    if (input) input.focus();
                }
            });

            // Selection logic for standard nodes too
            textNode.on('click tap', () => {
                this.selectTextNode(textNode, null); // null itemData implies standard node
                this.activeTextTarget = fieldName;
            });
        }

        saveState() {
            // Save current state for undo/redo
            if (this.slides[this.currentSlide]) {
                // Deep copy the slide to ensure text_styles is also copied
                this.undoStack.push(JSON.stringify(this.slides[this.currentSlide]));
                if (this.undoStack.length > 50) this.undoStack.shift();
                this.redoStack = [];
            }
        }

        setupEventListeners() {
            // Navigation
            document.getElementById('prevSlide').addEventListener('click', async () => {
                if (this.currentSlide > 0) {
                    await this.saveCurrentSlideContent(); // Save current slide before navigating
                    this.currentSlide--;
                    this.renderSlide(this.currentSlide);
                    this.updateSlidesList();
                }
            });

            // Magic Adapt Button
            const adaptBtn = document.getElementById('adaptContentBtn');
            if (adaptBtn) {
                console.log(' Magic Adapt button found and listener attached');
                adaptBtn.addEventListener('click', () => {
                    console.log(' Magic Adapt Button Clicked!');
                    // alert('Adapt Button Clicked!'); // Debug alert
                    this.adaptContent();
                });
            } else {
                console.error(' Magic Adapt Button NOT FOUND in DOM');
            }

            document.getElementById('nextSlide').addEventListener('click', async () => {
                if (this.currentSlide < this.slides.length - 1) {
                    await this.saveCurrentSlideContent(); // Save current slide before navigating
                    this.currentSlide++;
                    this.renderSlide(this.currentSlide);
                    this.updateSlidesList();
                }
            });

            // Layout Vibe Buttons
            document.querySelectorAll('.layout-vibe-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const vibe = btn.dataset.vibe;

                    if (this.slides.length > 0) {
                        // Apply to ALL slides
                        this.slides.forEach(slide => {
                            slide.layout_vibe = vibe;
                        });

                        // Re-render current
                        this.renderSlide(this.currentSlide);
                        this.renderSlidesList();

                        // Update UI buttons
                        document.querySelectorAll('.layout-vibe-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        // Save current (others will save when visited)
                        this.debouncedSave();
                        toastr.info(`Layout applied to ALL ${this.slides.length} slides: ${btn.innerText.split('\n')[0]}`);
                    }
                });
            });

            // Design controls
            document.getElementById('bgColor').addEventListener('change', (e) => {
                if (this.slides[this.currentSlide]) {
                    this.slides[this.currentSlide].background_color = e.target.value;
                    this.renderSlide(this.currentSlide);
                    this.renderSlidesList();
                    toastr.info('Background color updated');
                }
            });

            document.getElementById('fontColor').addEventListener('change', (e) => {
                if (this.slides[this.currentSlide]) {
                    const newColor = e.target.value;
                    const slide = this.slides[this.currentSlide];
                    slide.font_color = newColor; // Update general font color

                    if (!slide.text_styles) slide.text_styles = {};

                    if (this.activeTextTarget) {
                        // Apply to specific selected node
                        if (this.activeTextTarget.startsWith('extra_text_')) {
                            const id = this.activeTextTarget.replace('extra_text_', '');
                            const item = slide.extra_texts.find(t => t.id === id);
                            if (item) {
                                if (!item.styles) item.styles = {};
                                item.styles.fill = newColor;
                            }
                        } else {
                            // Apply to standard node (title, description, extraText)
                            if (!slide.text_styles[this.activeTextTarget]) slide.text_styles[this.activeTextTarget] = {};
                            slide.text_styles[this.activeTextTarget].fill = newColor;
                        }
                    } else {
                        // If no specific node selected, apply to all standard nodes if they don't have specific overrides
                        ['title', 'description', 'extraText'].forEach(target => {
                            if (!slide.text_styles[target] || !slide.text_styles[target].fill) {
                                if (!slide.text_styles[target]) slide.text_styles[target] = {};
                                slide.text_styles[target].fill = newColor;
                            }
                        });
                    }
                    this.renderSlide(this.currentSlide);
                    toastr.info('Font color updated');
                }
            });

            document.getElementById('fontFamily').addEventListener('change', (e) => {
                if (this.slides[this.currentSlide]) {
                    const newFontFamily = e.target.value;
                    const slide = this.slides[this.currentSlide];

                    if (!slide.text_styles) slide.text_styles = {};

                    if (this.activeTextTarget) {
                        // Apply to specific selected node
                        if (this.activeTextTarget.startsWith('extra_text_')) {
                            const id = this.activeTextTarget.replace('extra_text_', '');
                            const item = slide.extra_texts.find(t => t.id === id);
                            if (item) {
                                if (!item.styles) item.styles = {};
                                item.styles.fontFamily = newFontFamily;
                            }
                        } else {
                            // Apply to standard node (title, description, extraText)
                            if (!slide.text_styles[this.activeTextTarget]) slide.text_styles[this.activeTextTarget] = {};
                            slide.text_styles[this.activeTextTarget].fontFamily = newFontFamily;
                        }
                    } else {
                        // If no specific node selected, apply to all standard nodes if they don't have specific overrides
                        ['title', 'description', 'extraText'].forEach(target => {
                            if (!slide.text_styles[target] || !slide.text_styles[target].fontFamily) {
                                if (!slide.text_styles[target]) slide.text_styles[target] = {};
                                slide.text_styles[target].fontFamily = newFontFamily;
                            }
                        });
                    }
                    this.renderSlide(this.currentSlide);
                    toastr.info('Font family updated');
                }
            });

            document.getElementById('layout').addEventListener('change', (e) => {
                if (this.layer && this.slides[this.currentSlide]) {
                    const layout = e.target.value;
                    const title = this.layer.findOne('.title');
                    const description = this.layer.findOne('.description');
                    const extraText = this.layer.findOne('.extraText');

                    if (title && description) {
                        const width = this.stage.width();
                        const height = this.stage.height();

                        // Reset offsets for accurate positioning
                        title.offsetX(0);
                        description.offsetX(0);
                        if (extraText) extraText.offsetX(0);

                        switch (layout) {
                            case 'centered':
                                title.x(width / 2);
                                title.y(height / 3 - 40);
                                description.x(width / 2);
                                description.y(height / 2 + 20);
                                if (extraText) {
                                    extraText.x(width / 2);
                                    extraText.y(height / 2 + 80);
                                }
                                break;
                            case 'left':
                                title.x(width * 0.1);
                                title.y(height / 3 - 40);
                                description.x(width * 0.1);
                                description.y(height / 2 + 20);
                                if (extraText) {
                                    extraText.x(width * 0.1);
                                    extraText.y(height / 2 + 80);
                                }
                                break;
                            case 'split':
                                title.x(width * 0.1);
                                title.y(height / 3);
                                description.x(width * 0.6);
                                description.y(height / 3);
                                if (extraText) {
                                    extraText.x(width * 0.1); // Or adjust based on split layout
                                    extraText.y(height / 3 + 100);
                                }
                                break;
                            case 'top':
                                title.x(width / 2);
                                title.y(height * 0.2);
                                description.x(width / 2);
                                description.y(height * 0.4);
                                if (extraText) {
                                    extraText.x(width / 2);
                                    extraText.y(height * 0.6);
                                }
                                break;
                        }

                        // Re-apply center offsets if needed for alignment
                        title.offsetX(title.width() / 2);
                        description.offsetX(description.width() / 2);
                        if (extraText) extraText.offsetX(extraText.width() / 2);

                        // Update local slide state with new positions
                        const slide = this.slides[this.currentSlide];
                        slide.title_x = Math.round(title.x());
                        slide.title_y = Math.round(title.y());
                        slide.description_x = Math.round(description.x());
                        slide.description_y = Math.round(description.y());
                        if (extraText) {
                            slide.extra_text_x = Math.round(extraText.x());
                            slide.extra_text_y = Math.round(extraText.y());
                        }

                        this.layer.batchDraw();
                        this.debouncedSave(); // Save layout changes
                        toastr.info('Layout updated');
                    }
                }
            });

            // Content update listener removed - now handled dynamically

            // Regenerate slide with AI
            const regenerateBtn = document.getElementById('regenerateSlide');
            if (regenerateBtn) {
                regenerateBtn.addEventListener('click', async () => {
                    if (!this.slides[this.currentSlide]) {
                        toastr.error('No slide selected');
                        return;
                    }

                    const slide = this.slides[this.currentSlide];
                    const topic = slide.title || 'Slide content';

                    toastr.info('Regenerating slide content with AI...');

                    try {
                        const response = await fetch('/api/regenerate-slide/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCSRFToken()
                            },
                            body: JSON.stringify({
                                slide_id: slide.id,
                                topic: topic
                            })
                        });

                        const data = await response.json();

                        if (data.success) {
                            // Update slide with new content
                            Object.assign(slide, data.slide);
                            // Ensure text_styles is parsed if it comes back as a string
                            if (typeof slide.text_styles === 'string') {
                                slide.text_styles = JSON.parse(slide.text_styles);
                            }
                            if (typeof slide.extra_texts === 'string') {
                                slide.extra_texts = JSON.parse(slide.extra_texts);
                            }
                            this.renderSlide(this.currentSlide);
                            this.renderSlidesList();
                            toastr.success('Slide regenerated with AI!');
                        } else {
                            toastr.error(data.error || 'Failed to regenerate slide');
                        }
                    } catch (error) {
                        console.error('Error regenerating slide:', error);
                        toastr.error('Failed to regenerate slide');
                    }
                });
            }

            // Generate image
            const genImgBtn = document.getElementById('generateImageBtn');
            if (genImgBtn) {
                genImgBtn.addEventListener('click', async () => {
                    const prompt = document.getElementById('imagePrompt').value;
                    if (!prompt.trim()) {
                        toastr.error('Please enter an image description');
                        return;
                    }

                    if (!this.slides[this.currentSlide]) {
                        toastr.error('No slide selected');
                        return;
                    }

                    const slide = this.slides[this.currentSlide];
                    toastr.info('Generating saystory-style image...');

                    const btn = document.getElementById('generateImageBtn');
                    const originalText = btn.innerHTML;
                    btn.disabled = true;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                    await this.generateImageForSlide(slide, prompt);

                    btn.disabled = false;
                    btn.innerHTML = originalText;
                });
            }

            // Export single slide as PNG
            document.getElementById('exportSlideBtn').addEventListener('click', async () => {
                if (!this.slides[this.currentSlide]) {
                    toastr.error('No slide to export');
                    return;
                }

                const slide = this.slides[this.currentSlide];
                const slideNum = this.currentSlide + 1;

                toastr.info(`Exporting slide ${slideNum}...`);

                try {
                    // Wait for any pending renders
                    await new Promise(resolve => setTimeout(resolve, 300));

                    // Export as image data URL
                    const dataURL = this.stage.toDataURL({
                        mimeType: 'image/png',
                        quality: 1.0,
                        pixelRatio: 3
                    });

                    // Create download link with naming format: carousel_slides_{projectId}_slide_{slideNum}.png
                    const link = document.createElement('a');
                    link.download = `carousel_slides_${this.projectId}_slide_${slideNum}.png`;
                    link.href = dataURL;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    toastr.success(`Slide ${slideNum} exported successfully!`);
                } catch (error) {
                    console.error('Error exporting slide:', error);
                    toastr.error('Failed to export slide');
                }
            });

            // Export all as ZIP
            document.getElementById('exportBtn').addEventListener('click', () => {
                this.exportSlides();
            });



            document.getElementById('fullscreen').addEventListener('click', () => {
                const container = document.getElementById('konvaContainer');
                if (!document.fullscreenElement) {
                    container.requestFullscreen().catch(err => {
                        console.error('Error attempting to enable fullscreen:', err);
                    });
                } else {
                    document.exitFullscreen();
                }
            });

            // Undo/Redo
            document.getElementById('undo').addEventListener('click', () => {
                if (this.undoStack.length > 0) {
                    const previousState = this.undoStack.pop();
                    this.redoStack.push(JSON.stringify(this.slides[this.currentSlide]));
                    this.slides[this.currentSlide] = JSON.parse(previousState);
                    // Ensure text_styles is parsed after undo
                    if (typeof this.slides[this.currentSlide].text_styles === 'string') {
                        this.slides[this.currentSlide].text_styles = JSON.parse(this.slides[this.currentSlide].text_styles);
                    }
                    if (typeof this.slides[this.currentSlide].extra_texts === 'string') {
                        this.slides[this.currentSlide].extra_texts = JSON.parse(this.slides[this.currentSlide].extra_texts);
                    }
                    this.renderSlide(this.currentSlide);
                    this.renderSlidesList();
                    toastr.info('Undo applied');
                }
            });

            // Add Extra Text Button Listeners
            const AddExtraBtn = document.getElementById('addExtraTextBtn');
            if (AddExtraBtn) {
                AddExtraBtn.addEventListener('click', () => {
                    this.addExtraText();
                });
            }

            // Listeners for Selected Text Controls (Debounced)
            const selectedColor = document.getElementById('selectedColor');
            if (selectedColor) {
                let debounceTimer;
                selectedColor.addEventListener('input', (e) => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        this.applyStyleToActiveTarget('fill', e.target.value);
                    }, 50);
                });
            }

            const selectedFontSize = document.getElementById('selectedFontSize');
            if (selectedFontSize) {
                let debounceTimer;
                selectedFontSize.addEventListener('input', (e) => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        this.applyStyleToActiveTarget('fontSize', parseInt(e.target.value));
                    }, 50);
                });
            }

            const selectedFontFamily = document.getElementById('selectedFontFamily');
            if (selectedFontFamily) {
                selectedFontFamily.addEventListener('change', (e) => {
                    this.applyStyleToActiveTarget('fontFamily', e.target.value);
                });
            }

            // Auto-save slide content and dynamic update
            const textFields = [
                { id: 'slideTitle', target: 'title' },
                { id: 'slideDescription', target: 'description' }
            ];

            textFields.forEach(field => {
                const element = document.getElementById(field.id);
                if (element) {
                    element.addEventListener('input', (e) => {
                        const newVal = e.target.value;

                        // 1. Update local state immediately
                        if (this.slides[this.currentSlide]) {
                            if (field.target === 'title') this.slides[this.currentSlide].title = newVal;
                            if (field.target === 'description') this.slides[this.currentSlide].description = newVal;
                            if (field.target === 'extraText') this.slides[this.currentSlide].extra_text = newVal;
                        }

                        // 2. update Canvas immediately
                        if (this.layer) {
                            const node = this.layer.findOne(`.${field.target}`);
                            // Also try name selector if class selector fails (Konva names are not classes)
                            const nodeByName = this.layer.findOne(`.${field.target}`);

                            if (nodeByName) {
                                let textToDisplay = newVal;
                                // Apply transform if exists in styles
                                if (this.slides[this.currentSlide].text_styles &&
                                    this.slides[this.currentSlide].text_styles[field.target] &&
                                    this.slides[this.currentSlide].text_styles[field.target].textTransform) {
                                    const transform = this.slides[this.currentSlide].text_styles[field.target].textTransform;
                                    if (transform === 'uppercase') textToDisplay = newVal.toUpperCase();
                                    else if (transform === 'lowercase') textToDisplay = newVal.toLowerCase();
                                    else if (transform === 'capitalize') textToDisplay = newVal.replace(/\b\w/g, l => l.toUpperCase());
                                }
                                nodeByName.text(textToDisplay);
                                this.layer.batchDraw();
                            } else {
                                // Provide fallback if the specific node isn't found (e.g. extraText might not exist yet)
                                // If extraText node doesn't exist but we define it, we might need to re-render.
                                // But for performance, let's just try to update via renderSlide for now if node missing
                                // or just wait for debounce save?
                                // Let's rely on renderSlide if node is missing (new text added).
                                // But reusing renderSlide kills input focus? NO, input is outside saystorys.
                                // So renderSlide is safe.
                                if (field.target === 'extraText' && !nodeByName) {
                                    this.renderSlide(this.currentSlide);
                                }
                            }
                        }

                        // 3. Update Sidebar List Preview (Throttled?)
                        // We can just update it.
                        // Find the slide item title
                        const slideItem = document.querySelector(`.slide-item[data-index="${this.currentSlide}"]`);
                        if (slideItem) {
                            if (field.target === 'title') {
                                const titleEl = slideItem.querySelector('.slide-item-title');
                                if (titleEl) titleEl.textContent = newVal || `Slide ${this.currentSlide + 1}`;
                            }
                        }


                        // 4. Debounce auto-save to backend
                        this.debouncedSave();
                    });
                }
            });

            // Specific handler for Image Prompt (no saystorys update needed, just save)
            const promptField = document.getElementById('slideImagePrompt');
            if (promptField) {
                promptField.addEventListener('input', (e) => {
                    if (this.slides[this.currentSlide]) {
                        this.slides[this.currentSlide].image_prompt = e.target.value;
                    }
                });
            }






            // Add slide button
            document.getElementById('addSlide').addEventListener('click', async () => {
                const addSlideBtn = document.getElementById('addSlide');
                addSlideBtn.disabled = true;

                try {
                    if (!this.projectId) {
                        toastr.error('No project loaded');
                        return;
                    }

                    // Save any pending changes
                    if (this.autoSaveTimeout) {
                        clearTimeout(this.autoSaveTimeout);
                        await this.saveCurrentSlideContent();
                    }

                    const response = await fetch('/api/add-slide/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCSRFToken()
                        },
                        body: JSON.stringify({
                            project_id: this.projectId
                        })
                    });

                    const data = await response.json();

                    if (data.success) {
                        // Add to local state
                        // Ensure text_styles is parsed if it comes back as a string
                        if (typeof data.slide.text_styles === 'string') {
                            data.slide.text_styles = JSON.parse(data.slide.text_styles);
                        }
                        if (typeof data.slide.extra_texts === 'string') {
                            data.slide.extra_texts = JSON.parse(data.slide.extra_texts);
                        }
                        this.slides.push(data.slide);
                        this.currentSlide = this.slides.length - 1;

                        // Update UI counters
                        // Update UI counters
                        const totalSlidesEl = document.getElementById('totalSlides');
                        if (totalSlidesEl) totalSlidesEl.textContent = this.slides.length;

                        const currentSlideEl = document.getElementById('currentSlide');
                        if (currentSlideEl) currentSlideEl.textContent = `Slide ${this.currentSlide + 1} of ${this.slides.length}`;

                        // Force immediate list update
                        this.renderSlidesList();

                        // Try to render saystorys, but don't fail entire operation if it errors
                        try {
                            await this.renderSlide(this.currentSlide);
                            this.updateUIControls(data.slide, this.currentSlide);
                        } catch (renderError) {
                            console.error('Error rendering new slide saystorys:', renderError);
                            toastr.warning('Slide added but preview might be incomplete');
                        }

                        toastr.success('New slide added');
                    } else {
                        toastr.error(data.error || 'Failed to add slide');
                    }
                } catch (error) {
                    console.error('Error adding slide:', error);
                    toastr.error('Failed to add slide');
                } finally {
                    addSlideBtn.disabled = false;
                }
            });

            // update Canvas size
            document.getElementById('updatesaystorysSize').addEventListener('click', async () => {
                const width = parseInt(document.getElementById('saystorysWidth').value);
                const height = parseInt(document.getElementById('saystorysHeight').value);

                if (!width || !height || width < 100 || height < 100 || width > 4000 || height > 4000) {
                    toastr.error('Please enter valid dimensions (100-4000px)');
                    return;
                }

                if (this.slides[this.currentSlide]) {
                    const slide = this.slides[this.currentSlide];
                    slide.saystorys_width = width;
                    slide.saystorys_height = height;

                    // Update via API
                    try {
                        const response = await fetch('/api/update-slide/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCSRFToken()
                            },
                            body: JSON.stringify({
                                slide_id: slide.id,
                                slide_data: {
                                    saystorys_width: width,
                                    saystorys_height: height
                                }
                            })
                        });

                        const data = await response.json();
                        if (data.success) {
                            // Re-render with new dimensions
                            await this.renderSlide(this.currentSlide);
                            toastr.success('saystorys size updated');
                        } else {
                            toastr.error(data.error || 'Failed to update Canvas size');
                        }
                    } catch (error) {
                        console.error('Error updating saystorys size:', error);
                        toastr.error('Failed to update Canvas size');
                    }
                }
            });

            // Apply platform template
            document.getElementById('applyTemplate').addEventListener('click', () => {
                const platform = document.getElementById('platformSelect').value;
                const format = document.getElementById('formatSelect').value;

                // Get dimensions from utils
                const dimensions = this.getPlatformDimensions(platform, format);

                document.getElementById('saystorysWidth').value = dimensions.width;
                document.getElementById('saystorysHeight').value = dimensions.height;

                toastr.info(`Applied ${platform} ${format} template (${dimensions.width}${dimensions.height})`);
            });

            // Image Upload Listeners
            this.setupImageListeners();

            // --- Event Listeners for Style Buttons (Bold, Italic, Underline) ---
            const handleStyleClick = (targetName, property, value, btn) => {
                const slide = this.slides[this.currentSlide];
                if (!slide) return;

                // Determine target node name
                let target = targetName;
                // If specific target passed (title/description), use it.

                // Initialize text_styles if missing
                if (!slide.text_styles) slide.text_styles = {};

                // Handle 'extra_text' item lookup vs standard nodes
                let item;
                if (target.startsWith('extra_text_')) {
                    const id = target.replace('extra_text_', '');
                    if (slide.extra_texts) {
                        item = slide.extra_texts.find(t => t.id === id);
                    }
                    if (!item) return; // Should not happen if target is valid
                    if (!item.styles) item.styles = {};
                } else {
                    if (!slide.text_styles[target]) slide.text_styles[target] = {};
                }

                // Get current value
                let currentVal;
                if (item) {
                    currentVal = item.styles[property];
                } else {
                    currentVal = slide.text_styles[target][property] || 'normal';
                }

                // Calculate New Value (Toggle Logic)
                let newValue = value;

                if (property === 'fontStyle') {
                    // Handle bold / italic
                    // Current could be 'normal', 'bold', 'italic', 'italic bold'
                    // We treat them as independent boolean flags roughly.
                    const isBold = currentVal.includes('bold');
                    const isItalic = currentVal.includes('italic');

                    if (value === 'bold') {
                        if (isBold) {
                            // Remove bold
                            newValue = currentVal.replace('bold', '').trim();
                        } else {
                            // Add bold
                            newValue = currentVal === 'normal' ? 'bold' : `${currentVal} bold`;
                        }
                    } else if (value === 'italic') {
                        if (isItalic) {
                            // Remove italic
                            newValue = currentVal.replace('italic', '').trim();
                        } else {
                            // Add italic
                            newValue = currentVal === 'normal' ? 'italic' : `${currentVal} italic`;
                        }
                    }
                    // Clean up
                    if (!newValue || newValue === '') newValue = 'normal';
                    newValue = newValue.replace(/\s+/g, ' ').trim();
                }

                if (property === 'textDecoration') {
                    // Simple toggle for underline
                    newValue = (currentVal === 'underline') ? '' : 'underline';
                }

                // Apply New Value
                if (item) {
                    item.styles[property] = newValue;
                } else {
                    slide.text_styles[target][property] = newValue;
                }

                // Update Button State
                btn.classList.toggle('active');

                // update Canvas Node
                const node = this.layer.findOne('.' + target) || this.layer.findOne(`[name="${target}"]`);
                if (node) {
                    node.setAttr(property, newValue);
                    this.layer.batchDraw();
                }

                this.debouncedSave();
            };

            // Attach Listeners
            // Title
            document.querySelectorAll('.title-weight-btn').forEach(btn => {
                btn.addEventListener('click', (e) => handleStyleClick('title', 'fontStyle', 'bold', e.currentTarget));
            });
            document.querySelectorAll('.title-style-btn').forEach(btn => {
                btn.addEventListener('click', (e) => handleStyleClick('title', 'fontStyle', 'italic', e.currentTarget));
            });
            document.querySelectorAll('.title-decoration-btn').forEach(btn => {
                btn.addEventListener('click', (e) => handleStyleClick('title', 'textDecoration', 'underline', e.currentTarget));
            });

            // Description
            document.querySelectorAll('.description-weight-btn').forEach(btn => {
                btn.addEventListener('click', (e) => handleStyleClick('description', 'fontStyle', 'bold', e.currentTarget));
            });
            document.querySelectorAll('.description-style-btn').forEach(btn => {
                btn.addEventListener('click', (e) => handleStyleClick('description', 'fontStyle', 'italic', e.currentTarget));
            });
            document.querySelectorAll('.description-decoration-btn').forEach(btn => {
                btn.addEventListener('click', (e) => handleStyleClick('description', 'textDecoration', 'underline', e.currentTarget));
            });

            // Selected (Extra Text)
            document.querySelectorAll('.selected-weight-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (this.activeTextTarget && this.activeTextTarget.startsWith('extra_text_'))
                        handleStyleClick(this.activeTextTarget, 'fontStyle', 'bold', e.currentTarget);
                });
            });
            document.querySelectorAll('.selected-style-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (this.activeTextTarget && this.activeTextTarget.startsWith('extra_text_'))
                        handleStyleClick(this.activeTextTarget, 'fontStyle', 'italic', e.currentTarget);
                });
            });
            document.querySelectorAll('.selected-decoration-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (this.activeTextTarget && this.activeTextTarget.startsWith('extra_text_'))
                        handleStyleClick(this.activeTextTarget, 'textDecoration', 'underline', e.currentTarget);
                });
            });

            // Delete Selected Element
            const deleteBtn = document.getElementById('deleteSelectedElementBtn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', () => {
                    if (this.activeTextTarget && this.activeTextTarget.startsWith('extra_text_')) {
                        const id = this.activeTextTarget.replace('extra_text_', '');
                        const slide = this.slides[this.currentSlide];
                        if (slide && slide.extra_texts) {
                            slide.extra_texts = slide.extra_texts.filter(t => t.id !== id);

                            const node = this.layer.findOne('.' + this.activeTextTarget) || this.layer.findOne(`[name="${this.activeTextTarget}"]`);
                            if (node) {
                                // Remove transformer if attached
                                if (this.transformer.nodes().includes(node)) {
                                    this.transformer.nodes([]);
                                }
                                node.destroy();
                                this.layer.batchDraw();
                            }

                            // Hide controls
                            const controls = document.getElementById('selectedTextControls');
                            if (controls) controls.style.display = 'none';
                            this.activeTextTarget = null;

                            this.debouncedSave();
                            toastr.success('Text element deleted');
                        }
                    }
                });
            }
        }

        drawGrid() {
            this.gridLayer.destroyChildren();

            const width = this.stage.width();
            const height = this.stage.height();
            const gridSize = 20;

            // Draw vertical lines
            for (let x = 0; x <= width; x += gridSize) {
                const line = new Konva.Line({
                    points: [x, 0, x, height],
                    stroke: 'rgba(0,0,0,0.1)',
                    strokeWidth: 1
                });
                this.gridLayer.add(line);
            }

            // Draw horizontal lines
            for (let y = 0; y <= height; y += gridSize) {
                const line = new Konva.Line({
                    points: [0, y, width, y],
                    stroke: 'rgba(0,0,0,0.1)',
                    strokeWidth: 1
                });
                this.gridLayer.add(line);
            }

            this.gridLayer.batchDraw();
        }

        addDragSnapping(node) {
            node.on('dragmove', (e) => {
                // No boundary checks - allow free movement
            });

            node.on('dragend', (e) => {
                const slide = this.slides[this.currentSlide];

                // Update based on node name/id
                if (node.name() === 'title') {
                    slide.title_x = Math.round(node.x());
                    slide.title_y = Math.round(node.y());
                } else if (node.name() === 'description') {
                    slide.description_x = Math.round(node.x());
                    slide.description_y = Math.round(node.y());
                } else if (node.name().startsWith('extra_text_')) {
                    // It's one of the array items
                    const id = node.name().replace('extra_text_', '');
                    const item = slide.extra_texts.find(t => t.id === id);
                    if (item) {
                        item.x = Math.round(node.x());
                        item.y = Math.round(node.y());
                    }
                }

                this.debouncedSave();
                this.saveState();
            });
        }

        renderExtraTextItem(item) {
            const styles = item.styles || {};

            const textNode = new Konva.Text({
                x: item.x || 50,
                y: item.y || 50,
                text: item.text || 'New Text',
                fontSize: styles.fontSize || 24,
                fontFamily: styles.fontFamily || 'Inter',
                fill: styles.fill || '#000000',
                fontStyle: styles.fontStyle || 'normal',
                align: styles.align || 'left',
                width: styles.width || 300,
                name: `extra_text_${item.id}`, // Unique Name
                draggable: true // Always draggable
            });

            this.layer.add(textNode);
            this.addDragSnapping(textNode);

            // Enable editing
            textNode.on('dblclick dbltap', () => {
                this.EditTextNode(textNode, item);
            });

            // Selection for styling
            textNode.on('click tap', () => {
                this.selectTextNode(textNode, item);
            });

            // Apply other styles
            if (styles.textTransform) {
                const originalText = textNode.text();
                if (styles.textTransform === 'uppercase') textNode.text(originalText.toUpperCase());
            }
        }

        selectTextNode(node, itemData) {
            // Highlight selected node (maybe add a transformer or just border?)
            // For now, just focus Controls
            this.currentSelectedTextId = itemData ? itemData.id : null;
            this.currentSelectedTarget = itemData ? `extra_text_${itemData.id}` : node.name();

            console.log('Selected:', this.currentSelectedTarget);

            // Update Sidebar values to match this node
            const styles = itemData ? (itemData.styles || {}) : {};

            // Show Selected Text Controls ONLY if it's an extra text item
            const selectedControls = document.getElementById('selectedTextControls');

            if (selectedControls) {
                // Check if it is an extra text node (starts with extra_text_)
                if (node.name().startsWith('extra_text_')) {
                    selectedControls.style.display = 'block';

                    // Update label with selected text content
                    const label = document.getElementById('selectedTextLabel');
                    if (label) {
                        const textContent = itemData ? itemData.text : node.text();
                        label.textContent = `Selected: "${textContent.substring(0, 15)}${textContent.length > 15 ? '...' : ''}"`;
                    }

                    // Populate values
                    const colorInput = document.getElementById('selectedColor');
                    if (colorInput) colorInput.value = styles.fill || node.fill() || '#000000';

                    const sizeInput = document.getElementById('selectedFontSize');
                    if (sizeInput) {
                        const size = styles.fontSize || node.fontSize() || 24;
                        sizeInput.value = size;
                        const display = document.getElementById('selectedFontSizeDisplay');
                        if (display) display.textContent = size + 'px';
                    }

                    const familyInput = document.getElementById('selectedFontFamily');
                    if (familyInput) familyInput.value = styles.fontFamily || node.fontFamily() || 'Inter';

                    // Update Style Buttons State
                    const currentStyle = styles.fontStyle || node.fontStyle() || 'normal';
                    const currentDecor = styles.textDecoration || node.textDecoration() || 'none';

                    // Bold
                    const isBold = currentStyle.includes('bold');
                    const boldBtn = document.querySelector('.selected-weight-btn');
                    if (boldBtn) {
                        isBold ? boldBtn.classList.add('active') : boldBtn.classList.remove('active');
                    }

                    // Italic
                    const isItalic = currentStyle.includes('italic');
                    const italicBtn = document.querySelector('.selected-style-btn');
                    if (italicBtn) {
                        isItalic ? italicBtn.classList.add('active') : italicBtn.classList.remove('active');
                    }

                    // Underline
                    const isUnderline = currentDecor.includes('underline');
                    const underlineBtn = document.querySelector('.selected-decoration-btn');
                    if (underlineBtn) {
                        isUnderline ? underlineBtn.classList.add('active') : underlineBtn.classList.remove('active');
                    }

                    // Show/Hide Delete Button based on context (always show for extra text)
                    const deleteBtn = document.getElementById('deleteSelectedElementBtn');
                    if (deleteBtn) deleteBtn.style.display = 'block';

                } else {
                    // Hide controls for Title or Description
                    selectedControls.style.display = 'none';
                }
            }

            // We need to tell the editor that subsequent style changes apply to THIS node.
            this.activeTextTarget = this.currentSelectedTarget;

            // Also update the global/legacy inputs if applicable (so they match if user uses them)
            // But having two sets of inputs might be confusing.
            // The "Selected Text" section is the source of truth for the selection.

            /*
               PROBLEM: The current event listeners for style changes (fontColor, etc.)
               use `this.slides[this.currentSlide].font_color` etc. and redraw.
               They don't know about `activeTextTarget`.
               
               I need to update `setupEventListeners` to check `activeTextTarget`.
            */
        }

        EditTextNode(textNode, itemData) {
            // Hide text node
            textNode.hide();
            this.layer.draw();

            // Create textarea over saystorys
            const textPosition = textNode.absolutePosition();
            const stageBox = this.stage.container().getBoundingClientRect();
            const areaPosition = {
                x: stageBox.left + textPosition.x,
                y: stageBox.top + textPosition.y
            };

            const textarea = document.createElement('textarea');
            document.body.appendChild(textarea);

            textarea.value = itemData ? itemData.text : textNode.text();
            textarea.style.position = 'absolute';
            textarea.style.top = areaPosition.y + 'px';
            textarea.style.left = areaPosition.x + 'px';
            textarea.style.width = textNode.width() - textNode.padding() * 2 + 'px';
            textarea.style.height = textNode.height() - textNode.padding() * 2 + 5 + 'px';
            textarea.style.fontSize = textNode.fontSize() + 'px';
            textarea.style.border = 'none';
            textarea.style.padding = '0px';
            textarea.style.margin = '0px';
            textarea.style.overflow = 'hidden';
            textarea.style.background = 'none';
            textarea.style.outline = 'none';
            textarea.style.resize = 'none';
            textarea.style.lineHeight = textNode.lineHeight();
            textarea.style.fontFamily = textNode.fontFamily();
            textarea.style.transformOrigin = 'left top';
            textarea.style.textAlign = textNode.align();
            textarea.style.color = textNode.fill();

            // Focus and handle blur
            textarea.focus();

            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    textarea.blur();
                }
            });

            textarea.addEventListener('blur', () => {
                const newVal = textarea.value;
                if (itemData) {
                    itemData.text = newVal;
                }
                textNode.text(newVal);
                textNode.show();
                this.layer.draw();
                document.body.removeChild(textarea);
                this.debouncedSave();
            });
        }

        // Helper to apply styles
        applyStyleToActiveTarget(property, value) {
            if (this.slides[this.currentSlide]) {
                const slide = this.slides[this.currentSlide];
                if (!slide.text_styles) slide.text_styles = {};

                if (this.activeTextTarget) {
                    // Apply to specific selected node
                    if (this.activeTextTarget.startsWith('extra_text_')) {
                        const id = this.activeTextTarget.replace('extra_text_', '');
                        const item = slide.extra_texts.find(t => t.id === id);
                        if (item) {
                            if (!item.styles) item.styles = {};
                            item.styles[property] = value;
                        }
                    } else {
                        // Apply to standard node
                        if (!slide.text_styles[this.activeTextTarget]) slide.text_styles[this.activeTextTarget] = {};
                        slide.text_styles[this.activeTextTarget][property] = value;
                    }
                } else {
                    // All standard nodes fallback
                    ['title', 'description', 'extraText'].forEach(target => {
                        if (!slide.text_styles[target]) slide.text_styles[target] = {};
                        slide.text_styles[target][property] = value;
                    });
                }
                this.renderSlide(this.currentSlide);
                this.debouncedSave(); // Ensure changes are saved
                // toastr.info(`${property} updated`); // too spammy for slider
            }
        }

        async addExtraText() {
            const slide = this.slides[this.currentSlide];
            if (!slide.extra_texts) slide.extra_texts = [];

            const newId = Date.now().toString(); // Simple ID
            const newText = {
                id: newId,
                text: 'New Text',
                x: 100,
                y: 100,
                styles: {
                    fontSize: 24,
                    fill: '#000000',
                    fontFamily: 'Inter'
                }
            };

            slide.extra_texts.push(newText);
            this.renderExtraTextItem(newText);
            this.layer.batchDraw();
            this.debouncedSave();
        }

        getPlatformDimensions(platform, format) {
            const dimensions = {
                'instagram': {
                    'square': { width: 1080, height: 1080 },
                    'portrait': { width: 1080, height: 1350 },
                    'story': { width: 1080, height: 1920 },
                    'landscape': { width: 1080, height: 608 }  // Fallback
                },
                'linkedin': {
                    'square': { width: 1080, height: 1080 },
                    'portrait': { width: 1080, height: 1350 },  // Fallback
                    'story': { width: 1080, height: 1920 },     // Fallback
                    'landscape': { width: 1200, height: 627 }
                }
            };

            return dimensions[platform]?.[format] || dimensions['instagram']['square'];
        }

        zoom(factor) {
            const oldScale = this.stage.scaleX();
            const newScale = oldScale * factor;

            const center = {
                x: this.stage.width() / 2,
                y: this.stage.height() / 2
            };

            const relatedTo = {
                x: (center.x - this.stage.x()) / oldScale,
                y: (center.y - this.stage.y()) / oldScale
            };

            this.stage.scale({ x: newScale, y: newScale });

            const newPos = {
                x: center.x - relatedTo.x * newScale,
                y: center.y - relatedTo.y * newScale
            };

            this.stage.position(newPos);
            this.scale = newScale;
            this.layer.batchDraw();
        }

        async exportSlides() {
            if (this.slides.length === 0) {
                toastr.error('No slides to export');
                return;
            }

            toastr.info('Preparing ZIP file with all slides...');

            try {
                const zip = new JSZip();
                const originalSlide = this.currentSlide;

                // Capture each slide as image and add to ZIP
                for (let i = 0; i < this.slides.length; i++) {
                    // Switch to the slide
                    this.currentSlide = i;
                    await this.renderSlide(i);

                    // Wait for render to complete
                    await new Promise(resolve => setTimeout(resolve, 400));

                    // Export as image data URL
                    const dataURL = this.stage.toDataURL({
                        mimeType: 'image/png',
                        quality: 1.0,
                        pixelRatio: 3
                    });

                    // Convert data URL to blob data
                    const base64Data = dataURL.split(',')[1];

                    // Add to ZIP with slide number as filename
                    zip.file(`slide_${i + 1}.png`, base64Data, { base64: true });

                    toastr.info(`Processed slide ${i + 1} of ${this.slides.length}`);
                }

                // Restore original slide view
                this.currentSlide = originalSlide;
                await this.renderSlide(originalSlide);

                // Generate ZIP and download
                toastr.info('Generating ZIP file...');
                const zipBlob = await zip.generateAsync({ type: 'blob' });

                // Create download link
                const downloadUrl = URL.createObjectURL(zipBlob);
                const link = document.createElement('a');
                link.href = downloadUrl;
                link.download = `carousel_slides_${this.projectId}.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(downloadUrl);

                toastr.success(`All ${this.slides.length} slides exported as ZIP!`);
            } catch (error) {
                console.error('Error exporting slides:', error);
                toastr.error('Failed to export slides: ' + error.message);
            }
        }

        async exportSlide(slideIndex) {
            // Switch to the slide
            this.currentSlide = slideIndex;
            await this.renderSlide(slideIndex);

            // Wait for render
            await new Promise(resolve => setTimeout(resolve, 300));

            // Export as image
            const dataURL = this.stage.toDataURL({
                mimeType: 'image/png',
                quality: 1.0,
                pixelRatio: 3
            });

            // Download
            const link = document.createElement('a');
            link.download = `slide_${slideIndex + 1}.png`;
            link.href = dataURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Small delay between exports
            await new Promise(resolve => setTimeout(resolve, 200));
        }

        setupImageListeners() {
            const uploadBtn = document.getElementById('uploadImageBtn');
            const fileInput = document.getElementById('imageUploadInput');

            if (uploadBtn && fileInput) {
                uploadBtn.addEventListener('click', () => {
                    fileInput.click();
                });

                fileInput.addEventListener('change', (e) => {
                    this.handleImageUpload(e);
                });
            }
        }

        async handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (!file.type.match('image.*')) {
                toastr.error('Please upload an image file (PNG, JPG)');
                return;
            }

            if (!this.slides[this.currentSlide]) {
                toastr.error('No slide selected');
                return;
            }

            // check file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                toastr.error('Image size must be less than 5MB');
                return;
            }

            const reader = new FileReader();
            reader.onload = async (event) => {
                const base64Data = event.target.result;

                // Create image object
                const slide = this.slides[this.currentSlide];
                if (!slide.user_images) slide.user_images = [];

                const newImage = {
                    id: Date.now().toString(),
                    src: base64Data,
                    x: 100,
                    y: 100,
                    width: 300,
                    height: 300,
                    rotation: 0
                };

                // Add to slide data
                slide.user_images.push(newImage);

                // Render immediately (append to layer)
                this.renderUserImage(newImage);
                this.layer.batchDraw();

                // Save
                this.debouncedSave();
                toastr.success('Image added to slide');

                // Reset input
                e.target.value = '';
            };
            reader.readAsDataURL(file);
        }

        renderUserImage(imgData) {
            const imageObj = new Image();
            imageObj.src = imgData.src;

            imageObj.onload = () => {
                const konvaImage = new Konva.Image({
                    x: imgData.x,
                    y: imgData.y,
                    image: imageObj,
                    width: imgData.width,
                    height: imgData.height,
                    rotation: imgData.rotation || 0,
                    name: `user_image_${imgData.id}`,
                    draggable: true,
                    id: imgData.id
                });

                this.layer.add(konvaImage);
                this.makeImageEditable(konvaImage, imgData);
                this.layer.batchDraw();
            };
        }

        makeImageEditable(imageNode, imgData) {
            // Selection logic
            imageNode.on('click tap', (e) => {
                // Detach existing transformer
                this.transformer.nodes([]);

                // Attach transformer to this node
                this.transformer.nodes([imageNode]);
                this.layer.batchDraw();

                // Set current selection
                this.currentSelectedImageId = imgData.id;
                this.currentSelectedTarget = `user_image_${imgData.id}`;

                // Stop propagation so stage click doesn't deselect immediately if implemented
                e.cancelBubble = true;
            });

            // Transform end
            imageNode.on('transformend', () => {
                // Update data
                imgData.x = Math.round(imageNode.x());
                imgData.y = Math.round(imageNode.y());
                imgData.rotation = Math.round(imageNode.rotation());

                // Bake scale into width/height
                const scaleX = imageNode.scaleX();
                const scaleY = imageNode.scaleY();

                imageNode.scaleX(1);
                imageNode.scaleY(1);

                imgData.width = Math.round(imageNode.width() * scaleX);
                imgData.height = Math.round(imageNode.height() * scaleY);

                imageNode.width(imgData.width);
                imageNode.height(imgData.height);

                this.layer.batchDraw();
                this.debouncedSave();
            });

            // Drag end
            imageNode.on('dragend', () => {
                imgData.x = Math.round(imageNode.x());
                imgData.y = Math.round(imageNode.y());
                this.debouncedSave();
            });
        }
    }

    // Text Controls Functionality
    class TextControls {
        constructor(editor) {
            this.editor = editor;
            this.isReady = true; // Editor is already initialized when TextControls is created
            this.init();
        }

        init() {
            console.log('Initializing TextControls');
            // Title Controls
            this.initColorControl('titleColor', 'title');
            this.initRangeControl('titleFontSize', 'title', 'fontSize');
            this.initSelectControl('titleFontFamily', 'title', 'fontFamily');
            // this.initButtonGroup('title-weight-btn', 'title', 'fontWeight', 'data-weight'); // Managed by CarouselEditor
            this.initButtonGroup('title-alignment-btn', 'title', 'align', 'data-align');

            // Description Controls
            this.initColorControl('descriptionColor', 'description');
            this.initRangeControl('descriptionFontSize', 'description', 'fontSize');
            this.initSelectControl('descriptionFontFamily', 'description', 'fontFamily');
            // this.initButtonGroup('description-weight-btn', 'description', 'fontWeight', 'data-weight'); // Managed by CarouselEditor
            this.initButtonGroup('description-alignment-btn', 'description', 'align', 'data-align');

            // General Text Controls
            this.initRangeControl('lineHeight', 'all', 'lineHeight');
            this.initRangeControl('letterSpacing', 'all', 'letterSpacing');
            this.initButtonGroup('transform-btn', 'all', 'textTransform', 'data-transform');
            console.log('TextControls initialization complete');
        }

        initColorControl(elementId, target) {
            const element = document.getElementById(elementId);
            if (element) {
                element.addEventListener('input', (e) => {
                    this.updateTextProperty(target, 'fill', e.target.value);
                });
            }
        }

        initRangeControl(elementId, target, property) {
            const element = document.getElementById(elementId);
            if (element) {
                element.addEventListener('input', (e) => {
                    let value = e.target.value;
                    if (property === 'fontSize') {
                        value = parseInt(value);
                    } else if (property === 'lineHeight') {
                        value = parseFloat(value);
                    } else if (property === 'letterSpacing') {
                        value = parseFloat(value);
                    }
                    this.updateTextProperty(target, property, value);
                });
            }
        }

        initSelectControl(elementId, target, property) {
            const element = document.getElementById(elementId);
            if (element) {
                element.addEventListener('change', (e) => {
                    this.updateTextProperty(target, property, e.target.value);
                });
            }
        }

        // Helper class methods usage
        initButtonGroup(className, target, property, dataAttr) {
            const buttons = document.querySelectorAll(`.${className}`);
            buttons.forEach(button => {
                button.addEventListener('click', (e) => {
                    // Remove active class from siblings
                    const siblings = button.parentElement.querySelectorAll(`.${className}`);
                    siblings.forEach(sib => sib.classList.remove('active'));
                    button.classList.add('active');

                    const value = button.getAttribute(dataAttr);
                    // Use editor's apply method
                    if (this.editor.applyStyleToActiveTarget) {
                        this.editor.applyStyleToActiveTarget(property, value);
                    } else {
                        // Fallback implementation if method not ready?
                        // Should technically be ready.
                    }
                });
            });
        }

        updateTextProperty(target, property, value) {
            console.log(`Updating ${target} ${property} to:`, value);
            if (!this.editor || !this.editor.layer) {
                console.warn('Editor or layer not available');
                return;
            }

            const layer = this.editor.layer;
            let textsToUpdate = [];

            // Determine targets
            if (target === 'all') {
                // If targeting all, we update all relevant nodes
                // But for storage, we must act on 'title', 'description', etc separately
                ['title', 'description', 'extraText'].forEach(t => this.updateTextProperty(t, property, value));
                return;
            } else {
                // Try to find by name selector (Konva uses .name)
                const node = layer.findOne('.' + target);
                if (node) textsToUpdate.push(node);
            }

            if (textsToUpdate.length === 0) {
                // console.warn(`No text objects found for target: ${target}`);
                return; // Might be extraText missing
            }

            // Update local state text_styles
            const slide = this.editor.slides[this.editor.currentSlide];
            if (slide) {
                if (!slide.text_styles) slide.text_styles = {};
                if (!slide.text_styles[target]) slide.text_styles[target] = {};

                // Map generic property to specific style
                if (property === 'fontWeight') {
                    slide.text_styles[target].fontStyle = (value === 'bold' ? 'bold' : 'normal');
                } else {
                    slide.text_styles[target][property] = value;
                }
            }

            textsToUpdate.forEach((text, index) => {
                try {
                    if (property === 'fontWeight') {
                        text.fontStyle(value === 'bold' ? 'bold' : 'normal');
                    } else if (property === 'align') {
                        text.align(value);
                    } else if (property === 'textTransform') {
                        // Visual update only for transform? Or permanent?
                        // Simple toggle for now
                        const originalText = text.text(); // Wait, this changes the text content!
                        // If we change content, we should update the 'title'/'description' field too?
                        // Complex. Let's just apply it.
                        switch (value) {
                            case 'uppercase': text.text(text.text().toUpperCase()); break;
                            case 'lowercase': text.text(text.text().toLowerCase()); break;
                        }
                    } else if (typeof text[property] === 'function') {
                        text[property](value);
                    }
                } catch (error) {
                    console.error(`Error updating text property ${property}:`, error);
                }
            });

            layer.batchDraw();
            this.editor.debouncedSave();
        }
    }

    // Initialize editor when page loads
    document.addEventListener('DOMContentLoaded', async () => {
        const pathParts = window.location.pathname.split('/');
        const projectId = pathParts[2];

        if (projectId && !isNaN(projectId)) {
            console.log('Initializing editor for project:', projectId);
            window.carouselEditor = new CarouselEditor(projectId);
            await window.carouselEditor.initialize();
            window.textControls = new TextControls(window.carouselEditor);
            console.log('Editor and TextControls initialized');
        } else {
            console.error('Invalid project ID provided:', projectId);
            toastr.error('Invalid project ID. Please generate a carousel first.');
            setTimeout(() => {
                window.location.href = '/';
            }, 2000);
        }
    });
</script>
{% endblock %}